<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo中添加本地图片</title>
    <url>/2022/07/11/Hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h2 id="两种方法"><a href="#两种方法" class="headerlink" title="两种方法"></a>两种方法</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><ul>
<li><p>在配置文件**_config.yml**里修改：<code>post_asset_folder: true</code></p>
<span id="more"></span>
</li>
<li><p>在Hexo安装目录下执行:<code>npm install hexo-asset-image --save</code>，这是下载安装一个可以上传本地图片的插件</p>
</li>
<li><p>等待一段时间之后，再运行<code>hexo n &quot;文章标题&quot;</code>来生成博文时，<code>/source/_post</code>文件夹中除了<code>文章标题.md</code>外，还有一个同名文件夹。</p>
</li>
<li><p>在新的博文中想引入图片时，可以先把图片复制到博文的同名文件夹，然后在.md中按照常规的方式饮用图片即可，如<code>![你想输入的替代文字](博文标题/图片名.jpg)</code>。<strong>注意，此处的图片路径必须使用相对路径</strong></p>
</li>
<li><p>执行<code>hexo g</code>,检查生成的页面中图片的src地址。此时生成页面中图片src地址应该与页面的相对路径一致（具体路径取决于页面路径格式设置）</p>
</li>
</ul>
<h3 id="第二种方法-recommended"><a href="#第二种方法-recommended" class="headerlink" title="第二种方法(recommended)"></a>第二种方法(recommended)</h3><p>以上方法可以解决本地图片上传和引用的问题，但是在每个文章下建立资源文件夹好处是分类清楚，缺点是图片复用不方便，也不符合网站设计的一般规范。</p>
<p>所以我们可以第二种方案：</p>
<ul>
<li>在本地source中建立img文件夹，将引用到的图片全部放在此文件夹中。这样操作也便于图片的复用。</li>
<li><strong>采用这种方法时无需修改_config.yml,也无需安装hexo-asset-image</strong></li>
</ul>
<hr>
<h3 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h3><blockquote>
<p><a href="https://ashooter.github.io/2018-11-15/%E5%A6%82%E4%BD%95%E5%9C%A8Hexo%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/">如何在Hexo中添加本地图片</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>notes</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 403: Frog Jump</title>
    <url>/2022/07/15/LeetCode-403-Frog-Jump/</url>
    <content><![CDATA[<h2 id="403-Frog-Jump-Hard"><a href="#403-Frog-Jump-Hard" class="headerlink" title="403. Frog Jump (Hard)"></a>403. Frog Jump (Hard)</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question:"></a>Question:</h3><p>A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.</p>
<p>Given a list of <code>stones&#39;</code> positions (in units) in sorted <strong>ascending order</strong>, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be <code>1</code> unit.</p>
<p>If the frog’s last jump was <code>k</code> units, its next jump must be either <code>k - 1</code>, <code>k</code>, or <code>k + 1</code> units. The frog can only jump in the forward direction.</p>
<span id="more"></span>

<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><pre><code>Input: stones = [0,1,3,5,6,8,12,17]
Output: true
Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.
</code></pre>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><pre><code>Input: stones = [0,1,2,3,4,8,9,11]
Output: false
Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.
</code></pre>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p><strong>动态规划</strong></p>
<pre><code>状态转移方程：
dp[i][k] = dp[j][k-1] || dp[j][k] || dp[j][k+1]
</code></pre>
<p><strong>解析</strong></p>
<ol>
<li>首先很明确每一个点由上一个点跳跃过来的有可能的最大值就是这个点的 index (画一下就知道了)</li>
<li><strong>!<strong>上述方程: 第一层 arr 表示 index (i 是当前 ind, j 为上一个, 也可能再上一个等等), 第二层 arr 表示之前的</strong>所有有可能的石头位置</strong>跳到当前 ind 所用的距离. (如果是某个距离,则在该距离对应的 ind 下标记为 true, 表明他可能是由前面的某个石头花了 k 个距离跳来的)</li>
<li>从等号右边找对应, 如果<code>之前的(所有的可能性, 后面会用到遍历, 注意j不仅仅只是上一个)石头跳到前一个石头的距离</code>和<code>前一个石头跳到当前位置距离差距</code>只有 1 内, 那么这个可能性存在</li>
</ol>
<h3 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; stones</span><br><span class="line"> * @return &#123;boolean&#125;</span><br><span class="line"> */</span><br><span class="line">var canCross = function(stones) &#123;</span><br><span class="line">    let n = stones.length;</span><br><span class="line">    let dp = new Array(n).fill(0).map(()=&gt;new Array(n).fill(0))</span><br><span class="line">    dp[0][0] = true</span><br><span class="line"></span><br><span class="line">    for (let i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        if (stones[i] - stones[i-1] &gt; i) return false</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (let i = 1; i &lt; n; i++)&#123;</span><br><span class="line">        for (let j = i-1; j &gt;= 0; j--)&#123;</span><br><span class="line">            let diff = stones[i] - stones[j] // 当前i和之前的某一个i(j)的距离, 下一次遍历则是比较再前一个(j--), 如果再前一个也可以跳到这里, 那么这个差距也存储 (相当于把能跳到这里的所有可能的跳跃距离都存上了!)</span><br><span class="line">            if (diff &gt; j + 1) break // 如果扫描到离得很远以至于diff比ind差更远的,就直接跳过啦</span><br><span class="line">            dp[i][diff] =  dp[j][diff - 1] || dp[j][diff] || dp[j][diff + 1] // 注意这里不仅比较一个j,还有j--, 比较所有j能跳到这里的距离, 相当于如果前一个距离这里太近还不到diff-1(不符合), 则下一次遍历会去找到j--,相当于再前一个跳到这里的距离)</span><br><span class="line">            if (dp[i][diff] &amp;&amp; i === n-1) return true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return false</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>study</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 62: Unique Paths</title>
    <url>/2022/07/12/LeetCode-62-Unique-Paths/</url>
    <content><![CDATA[<h2 id="62-Unique-Paths-Med"><a href="#62-Unique-Paths-Med" class="headerlink" title="62. Unique Paths (Med)"></a>62. Unique Paths (Med)</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question:"></a>Question:</h3><p>There is a robot on an <code>m x n</code> grid. The robot is initially located at the top-left corner (i.e., <code>grid[0][0]</code>). The robot tries to move to the bottom-right corner (i.e., <code>grid[m - 1][n - 1]</code>). The robot can only move either down or right at any point in time.</p>
<p>Given the two integers <code>m</code> and <code>n</code>, return the number of possible unique paths that the robot can take to reach the bottom-right corner.</p>
<p>The test cases are generated so that the answer will be less than or equal to 2 * 10<sup>9</sup>.</p>
<span id="more"></span>

<h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1:"></a>Example 1:</h3><p><img data-src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png"></p>
<pre><code>Input: m = 3, n = 7
Output: 28
</code></pre>
<h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2:"></a>Example 2:</h3><pre><code>Input: m = 3, n = 2
Output: 3
Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
1. Right -&gt; Down -&gt; Down
2. Down -&gt; Down -&gt; Right
3. Down -&gt; Right -&gt; Down
</code></pre>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法:"></a>解法:</h3><ol>
<li><p><strong>理解:</strong> 不难发现，机器人从左上角走到右下角，需要向下走<code>m - 1</code>步，向右走<code>n - 1</code>步</p>
</li>
<li><p><strong>动态规划:</strong></p>
</li>
</ol>
<ul>
<li><p>建立二维数组dp，令<code>dp[i][j]</code>表示到达 i, j的最多路径数。 </p>
</li>
<li><p>初始化：对于第一行 <code>dp[0][j]</code>，或者第一列 <code>dp[i][0]</code>，都只有一条路径。 </p>
</li>
<li><p>机器人到达位置<code>(i, j)</code>有两种方式：从<code>(i - 1, j)</code>下移和从<code>(i, j - 1)</code>右移。状态转移方程为： </p>
<p>  <code>d p [ i ] [ j ] = d p [ i − 1 ] [ j ] + d p [ i ] [ j − 1 ]</code></p>
</li>
</ul>
<ol start="3">
<li><strong>复杂度分析:</strong></li>
</ol>
<ul>
<li>时间复杂度：<em>O(mn)</em> 遍历dp数组进行动态规划。</li>
<li>空间复杂度：<em>O(mn)</em> 创建的dp数组的大小。</li>
</ul>
<ul>
<li><h3 id="好理解版本"><a href="#好理解版本" class="headerlink" title="好理解版本"></a>好理解版本</h3></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number&#125; m</span><br><span class="line"> * @param &#123;number&#125; n</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var uniquePaths = function(m, n) &#123;</span><br><span class="line">    // 创建容器数组</span><br><span class="line">    let dp = Array(m).fill(0).map(() =&gt; Array(n).fill(0))</span><br><span class="line"></span><br><span class="line">    // 最上一行和最下一行初始值为1</span><br><span class="line">    for (let i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        for (let j = 0; j &lt; n; j++)&#123;</span><br><span class="line">            if (i === 0 | j === 0) dp[i][j] = 1</span><br><span class="line">            else&#123;</span><br><span class="line">                dp[i][j] = dp[i-1][j] + dp[i][j-1]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[m-1][n-1]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 速度 &gt; 80%, 空间 &gt; 40%</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="最优版本"><a href="#最优版本" class="headerlink" title="最优版本"></a>最优版本</h3></li>
</ul>
<p><em><strong>接下来，还可以将时间复杂度由O(n^2)优化为O(n)，主要由于状态转移方程中，当前状态主要取决于(i - 1)行和(j - 1)列，所以并不需要保存每一行的状态</strong></em></p>
<p><em><strong>dp可以优化为一维滚动数组。当第i次遍历到dp[j]时，dp[j]表示到达(i, j)最多的路径数。递推公式为： d p [ j ] + &#x3D; d p [ j − 1 ]</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var uniquePaths = function(m, n) &#123;</span><br><span class="line">    // 创建容器数组</span><br><span class="line">    let dp = Array(n).fill(0)</span><br><span class="line">    dp[0] = 1</span><br><span class="line"></span><br><span class="line">    // 最上一行和最下一行初始值为1</span><br><span class="line">    for (let i = 0; i &lt; m; i++)&#123;</span><br><span class="line">        for (let j = 1; j &lt; n; j++)&#123;</span><br><span class="line">            dp[j] += dp[j-1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[n-1]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 速度 &gt; 95%, 空间 &gt; 90%</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>study</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>给Github Pages添加自定义域名</title>
    <url>/2022/07/11/Pages%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>博客网站搭建好了，但访问的时候只能是以固定的域名形式（用户名.github.io）进行访问。这时可以通过购买域名的方式行实现自定义域名访问。可以去国外买或者国内，国内都是需要备案的。</p>
<h2 id="购买域名后："><a href="#购买域名后：" class="headerlink" title="购买域名后："></a>购买域名后：</h2><ol>
<li>首先是用ping命令找到存放你的github pages的主机的IP地址(或者去Github Pages Doc里找)，在终端里面用命令ping<br> xxx.github.io便可完成，下图中红框内的就是我们要找的IP地址：<span id="more"></span></li>
</ol>
<p><img data-src="https://s2.51cto.com/images/blog/202105/20/0512eaedbd589700a91cc59d3e37b64c.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="使用自定义域名来访问GitHub上部署的hugo博客——GitHub Pages_GitHub"></p>
<ol start="2">
<li>在购买域名的提供商为域名添加解析。我是在阿里云买的域名，因此我以阿里云的为例。在域名控制台选择想要绑定的域名，并点击解析：</li>
</ol>
<p><img data-src="https://s2.51cto.com/images/blog/202105/20/35b942d661269dd6b40f3d8a32853fe8.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="使用自定义域名来访问GitHub上部署的hugo博客——GitHub Pages_GitHub Pages_02"></p>
<ul>
<li>记录类型：CNAME 将一个域名指向例外一个域名，再由另一个域名提供IP地址，就需要添加 CNAME 记录。<br>主机记录：www 表示访问域名的时候以www开头为一级域名。如果是二级域名的话就在前面加上自己想要的参数，访问的时候也是以二级域名的形式访问。</li>
</ul>
<p><img data-src="https://s2.51cto.com/images/blog/202105/20/60c6863f819cb45d4d1460947bf0ae71.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="使用自定义域名来访问GitHub上部署的hugo博客——GitHub Pages_GitHub Pages_03"></p>
<ul>
<li>记录类型：A 将域名指向一个IPv4地址，如果需要将域名指向一个 IP 地址（外网地址），就需要添加 A 记录<br>主机记录：@ 表示访问的时候直接用 yunxdr.top 形式访问，前面不加任何参数。如果是www，就要以 <a href="http://www.yunxdr.top%E8%AE%BF%E9%97%AE%E3%80%82%E8%BF%99%E9%87%8C%E8%AE%BE%E7%BD%AE%E7%9A%84@形式与下面github上自定义的域名要对应/">www.yunxdr.top访问。这里设置的@形式与下面GitHub上自定义的域名要对应</a></li>
</ul>
<p><img data-src="https://s2.51cto.com/images/blog/202105/20/71ffdd069477ff0f54c6e99a3a6a4e71.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="使用自定义域名来访问GitHub上部署的hugo博客——GitHub Pages_GitHub Pages_04"></p>
<ol start="3">
<li>在上面存放静态网站的Repository Settings里面GitHubPages Custom domain（自定义域名）填上自己的域名点击save；</li>
</ol>
<p><img data-src="https://s2.51cto.com/images/blog/202105/20/464684d5f94bae03fc7f9b78d3b9e200.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="使用自定义域名来访问GitHub上部署的hugo博客——GitHub Pages_GitHub Pages_05"><br><img data-src="https://s2.51cto.com/images/blog/202105/20/d70a389b9f4a2c5a65673dd0e8d29147.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="使用自定义域名来访问GitHub上部署的hugo博客——GitHub Pages_GitHub Pages_06"></p>
<pre><code>设置完成后就可以通过 yunxdr.top 访问部署在GitHub上的hugo的网站了
</code></pre>
<p><img data-src="https://s2.51cto.com/images/blog/202105/20/22dcdbfc29349c3bf60028f2d9a679c4.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="使用自定义域名来访问GitHub上部署的hugo博客——GitHub Pages_GitHub_07"></p>
<h2 id="例外如果不太懂解析域名的可以参考如下资料："><a href="#例外如果不太懂解析域名的可以参考如下资料：" class="headerlink" title="例外如果不太懂解析域名的可以参考如下资料："></a>例外如果不太懂解析域名的可以参考如下资料：</h2><p><img data-src="https://s2.51cto.com/images/blog/202105/20/645eab10e04fdad97fb283e5b49ba03b.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="渲染结果"><br><img data-src="https://s2.51cto.com/images/blog/202105/20/12f8d9b219674566e500a98dbf42b3fe.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="渲染结果"><br>    关于记录值www和@的区别</p>
<ul>
<li><p>创建 <a href="http://www.dns-example.com/">www.dns-example.com</a> 的子域名。<br><img data-src="https://s2.51cto.com/images/blog/202105/20/9e9a4bccd513ffb7f8eddcf0ed53ef72.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="渲染结果"></p>
</li>
<li><p>创建 dns-example.com 的子域名。<br><img data-src="https://s2.51cto.com/images/blog/202105/20/fcaa518bb5d34d486ed8b981155c03ab.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="渲染结果"></p>
</li>
</ul>
<hr>
<h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref:"></a>Ref:</h2><blockquote>
<p><a href="https://blog.51cto.com/xdr630/2795777">使用自定义域名来访问GitHub上部署的hugo博客——GitHub Pages</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Notes</category>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>React笔记</title>
    <url>/2022/07/10/React%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>以下是观看尚硅谷React课程所做的笔记。</p>
<p><a href="https://www.bilibili.com/video/BV1wy4y1D7JT?p=43&t=5">视频链接</a></p>
</blockquote>
<h1 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h1><p><strong>react是什么？</strong></p>
<p>React用于构建用户界面的JS库。是一个将数据渲染为HTML视图的开源JS库。</p>
<p><strong>为什么学？</strong></p>
<p>1.原生JS操作DOM繁琐，效率低</p>
<p>2.使用JS直接操作DOM,浏览器会进行大量的重绘重排</p>
<span id="more"></span>

<p>3.原生JS没有组件化编码方案，代码复用低</p>
<blockquote>
<p>在学习之前最好看一下关于npm的知识：下面是我在网上看见的一个写的还不错的npm的文章</p>
<p><a href="https://blog.csdn.net/qq_25502269/article/details/79346545">npm</a></p>
</blockquote>
<h1 id="React入门"><a href="#React入门" class="headerlink" title="React入门"></a>React入门</h1><h2 id="React-基础案例"><a href="#React-基础案例" class="headerlink" title="React 基础案例"></a>React 基础案例</h2><p>1.先倒入三个包：</p>
<p>【先引入react.development.js，后引入react-dom.development.js】</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">react.development.js</span><br><span class="line">react-dom.development.js</span><br><span class="line">babel.min.js </span><br></pre></td></tr></table></figure>

<p>2.创建一个容器</p>
<p>3.创建虚拟DOM，渲染到容器中</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 准备好容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入依赖 ,引入的时候，必须就按照这个步骤--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/react.development.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/react-dom.development.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/babel.min.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--这里使用了babel用来解析jsx语法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1.创建虚拟DOM</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="variable constant_">VDOM</span> = <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>  <span class="comment">//这个地方使用的是JSX语法，不需要加&quot;&quot;</span></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2.渲染，如果有多个渲染同一个容器，后面的会将前面的覆盖掉</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="variable constant_">VDOM</span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));        </span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样，就会在页面中的这个div容器上添加这个h1.</p>
<p><img data-src="/images/react/1611196030416.png" alt="渲染结果"></p>
<h2 id="JSX基础语法"><a href="#JSX基础语法" class="headerlink" title="JSX基础语法"></a>JSX基础语法</h2><p>1.定义虚拟DOM，不能使用“”</p>
<p>2.标签中混入JS表达式的时候使用{}</p>
<p>3.样式的类名指定不要使用class，使用className</p>
<p>4.内敛样式要使用双大括号包裹</p>
<p>5.不能有多个根标签，只能有一个跟标签</p>
<p>6.标签必须闭合</p>
<p>7.如果小写字母开头，就将标签转化为html同名元素，如果html中无该标签对应的元素，就报错；如果是大写字母开头，react就去渲染对应的组件，如果没有就报错</p>
<blockquote>
<p>关于JS表达式和JS语句：</p>
<p>  JS表达式：返回一个值，可以放在任何一个需要值的地方  a  a+b  demo(a)  arr.map() function text(){}<br>  JS语句：if(){} for(){} while(){} swith(){} 不会返回一个值</p>
</blockquote>
<p>实例如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.sss</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 准备好容器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 引入依赖 ,引入的时候，必须就按照这个步骤--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/react.development.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/react-dom.development.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这里使用了js来创建虚拟DOM--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title class_">MyId</span> = <span class="string">&quot;title&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="title class_">MyData</span> = <span class="string">&quot;Cyk&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 1.创建虚拟DOM</span></span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">const</span> <span class="variable constant_">VDOM</span> = (</span></span><br><span class="line"><span class="language-javascript">            <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span> = <span class="string">&#123;MyId.toLocaleUpperCase()&#125;</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">                <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span> = <span class="string">&quot;sss&quot;</span> <span class="attr">style</span> = <span class="string">&#123;&#123;fontSize:</span>&#x27;<span class="attr">50px</span>&#x27;&#125;&#125;&gt;</span>sss<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span></span><br><span class="line"><span class="language-xml"><span class="language-javascript">            <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="language-javascript">        )</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 2.渲染，如果有多个渲染同一个容器，后面的会将前面的覆盖掉</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="variable constant_">VDOM</span>,<span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;test&quot;</span>));</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="两种创建虚拟DOM的方式"><a href="#两种创建虚拟DOM的方式" class="headerlink" title="两种创建虚拟DOM的方式"></a>两种创建虚拟DOM的方式</h2><p><strong>1.使用JSX创建虚拟DOM</strong></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = (</span><br><span class="line">           <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span> = <span class="string">&#123;MyId.toLocaleUpperCase()&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span> = <span class="string">&quot;sss&quot;</span> <span class="attr">style</span> = <span class="string">&#123;&#123;fontSize:</span>&#x27;<span class="attr">50px</span>&#x27;&#125;&#125;&gt;</span>sss<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">           <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">       )</span><br></pre></td></tr></table></figure>

<p>这个在上面的案例中已经演示过了 ，下面看看另外一种创建虚拟DOM的方式</p>
<p><strong>2.使用JS创建虚拟DOM</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.创建虚拟DOM[在这使用了js的语法]React.createElement(标签,标签属性,内容)</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">VDOM</span> = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;h1&#x27;</span>,&#123;<span class="attr">id</span>:<span class="string">&quot;title&quot;</span>&#125;,<span class="string">&quot;nihao&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用JS和JSX都可以创建虚拟DOM，但是可以看出JS创建虚拟DOM比较繁琐，尤其是标签如果很多的情况下，所以还是比较推荐使用JSX来创建。</p>
<h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><p>当应用是以多组件的方式实现，这个应用就是一个组件化的应用</p>
<blockquote>
<p><strong>注意：</strong> 组件名称必须以大写字母开头。</p>
<p>React 会将以小写字母开头的组件视为原生 DOM 标签。例如，&lt; div &#x2F;&gt;<code>代表 HTML 的 div 标签，而</code>&lt; Weclome &#x2F;&gt; 则代表一个组件，并且需在作用域内使用 <code>Welcome</code></p>
<p>传递的参数，不能在组件中改动</p>
</blockquote>
<h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.先创建函数，函数可以有参数，也可以没有，但是必须要有返回值 返回一个虚拟DOM</span><br><span class="line">function Welcome(props) &#123;</span><br><span class="line">  return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line">//2.进行渲染</span><br><span class="line">ReactDOM.Render(&lt;Welcom name = &quot;ss&quot; /&gt;,document.getElementById(&quot;div&quot;));</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/react/1611211670211.png" alt="结果"></p>
<p>让我们来回顾一下这个例子中发生了什么：</p>
<ol>
<li>我们调用 <code>ReactDOM.render()</code> 函数，并传入 <code>&lt;Welcome name=&quot;Sara&quot; /&gt;</code> 作为参数。</li>
<li>React 调用 <code>Welcome</code> 组件，并将 <code>&#123;name: &#39;Sara&#39;&#125;</code> 作为 props 传入。</li>
<li><code>Welcome</code> 组件将 <code>Hello, Sara</code> 元素作为返回值。</li>
<li>React DOM 将 DOM 高效地更新为 <code>Hello, Sara</code>。</li>
</ol>
<h2 id="Class组件"><a href="#Class组件" class="headerlink" title="Class组件"></a>Class组件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//必须继承React.Component</span><br><span class="line">//然后重写Render()方法，该方法一定要有返回值，返回一个虚拟DOM</span><br><span class="line">class Welcome extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">//渲染 【这个跟之前也是一样的】</span><br><span class="line">ReactDOM.Render(&lt;Welcom name = &quot;ss&quot; /&gt;,document.getElementById(&quot;div&quot;));</span><br></pre></td></tr></table></figure>

<p>执行过程：</p>
<p>​    1.React解析组件标签，找到相应的组件</p>
<p>​    2.发现组件是类定义的，随后new出来的类的实例，并通过该实例调用到原型上的render方法</p>
<p>​    3.将render返回的虚拟DOM转化为真实的DOM,随后呈现在页面中</p>
<h2 id="组件案例"><a href="#组件案例" class="headerlink" title="组件案例"></a>组件案例</h2><p>下面，我们通过一个案例更好的理解组件：【只关注与核心代码】</p>
<p>我们发现组件是可以包含中使用的， 而且如果创建的数组，必须要代一个key。数组元素中使用的 key 在其兄弟节点之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的 key 值 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line"></span><br><span class="line">        //创建一个组件&lt;li&gt;</span><br><span class="line">        function GetLi(props)&#123;      </span><br><span class="line">            return &lt;li&gt;&#123;props.value&#125;&lt;/li&gt;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        // 1.创建类式组件&lt;ul&gt;</span><br><span class="line">        class MyComponent extends React.Component&#123;</span><br><span class="line">            render()&#123;</span><br><span class="line">                console.log(this.props.arr);</span><br><span class="line">                let com = this.props.arr.map((item,index)=&gt;</span><br><span class="line">                     //在这个地方包含了GetLi这个组件，【注意不能用&#123;&#125;】</span><br><span class="line">                     //因为这个是一个列表，所以必须传递一个key【独一无二的Key】</span><br><span class="line">                     //key 帮助 React 识别哪些元素改变了，比如被添加或删除。</span><br><span class="line">                        &lt;GetLi value=&#123;item&#125; key = &#123;index&#125; /&gt;</span><br><span class="line">                    );</span><br><span class="line">                console.log(com);</span><br><span class="line">                return &lt;ul&gt;&#123;com&#125;&lt;/ul&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        let num = [1,2,3,4]</span><br><span class="line">        //2.渲染组件</span><br><span class="line">        ReactDOM.render(&lt;MyComponent  arr=&#123;num&#125;/&gt;,document.getElementById(&quot;test&quot;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="组件实例的三大属性"><a href="#组件实例的三大属性" class="headerlink" title="组件实例的三大属性"></a>组件实例的三大属性</h1><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>我们都说React是一个状态机，体现是什么地方呢，就是体现在state上，通过与用户的交互，实现不同的状态，然后去渲染UI,这样就让用户的数据和界面保持一致了。state是组件的私有属性。</p>
<p>在React中，更新组件的state，结果就会重新渲染用户界面(不需要操作DOM),一句话就是说，用户的界面会随着状态的改变而改变。</p>
<p>state是组件对象最重要的属性，值是对象（可以包含多个key-value的组合）</p>
<p><strong>案例</strong>：</p>
<p>1.需求：页面显示【今天天气很炎热】，鼠标点击文字的时候，页面更改为【今天天气很凉爽】</p>
<p>核心代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 准备好容器 --&gt;</span><br><span class="line">    &lt;div id=&quot;test&quot;&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- 引入依赖 ,引入的时候，必须就按照这个步骤--&gt;</span><br><span class="line">&lt;script src=&quot;../js/react.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;../js/react-dom.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!--这里使用了js来创建虚拟DOM--&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        //1.创建组件</span><br><span class="line">        class St extends React.Component&#123;</span><br><span class="line">            constructor(props)&#123;</span><br><span class="line">                super(props);</span><br><span class="line">                //先给state赋值</span><br><span class="line">                this.state = &#123;isHot:true,win:&quot;ss&quot;&#125;;</span><br><span class="line">                //找到原型的dem，根据dem函数创建了一个dem1的函数，并且将实例对象的this赋值过去</span><br><span class="line">                this.dem1 = this.dem.bind(this);</span><br><span class="line">            &#125;</span><br><span class="line">            //render会调用1+n次【1就是初始化的时候调用的，n就是每一次修改state的时候调用的】</span><br><span class="line">            render()&#123; //这个This也是实例对象</span><br><span class="line">                //如果加dem()，就是将函数的回调值放入这个地方</span><br><span class="line">                //this.dem这里面加入this，并不是调用，只不过是找到了dem这个函数，在调用的时候相当于直接调用，并不是实例对象的调用</span><br><span class="line">                return &lt;h1 onClick = &#123;this.dem1&#125;&gt;今天天气很&#123;this.state.isHot?&quot;炎热&quot;:&quot;凉爽&quot;&#125;&lt;/h1&gt;    </span><br><span class="line">            &#125;</span><br><span class="line">            //通过state的实例调用dem的时候，this就是实例对象</span><br><span class="line">            dem()&#123;</span><br><span class="line">                const state =  this.state.isHot;</span><br><span class="line">                 //状态中的属性不能直接进行更改，需要借助API</span><br><span class="line">                // this.state.isHot = !isHot; 错误</span><br><span class="line">                //必须使用setState对其进行修改，并且这是一个合并</span><br><span class="line">                this.setState(&#123;isHot:!state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 2.渲染，如果有多个渲染同一个容器，后面的会将前面的覆盖掉</span><br><span class="line">        ReactDOM.render(&lt;St /&gt;,document.getElementById(&quot;test&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>需要注意的是：</p>
<p>1.组件的构造函数，必须要传递一个props参数</p>
<p>2.特别关注this【重点】，类中所有的方法局部都开启了严格模式，如果直接进行调用，this就是undefined</p>
<p>3.想要改变state,需要使用setState进行修改，如果只是修改state的部分属性，则不会影响其他的属性，这个只是合并并不是覆盖。</p>
<p>this.setState()，该方法接收两种参数：对象或函数。</p>
<ol>
<li>对象：即想要修改的state</li>
<li>函数：接收两个函数，第一个函数接受两个参数，第一个是当前state，第二个是当前props，该函数返回一个对象，和直接传递对象参数是一样的，就是要修改的state；第二个函数参数是state改变后触发的回调</li>
</ol>
<p>在此还需要注意的是，setState有异步更新和同步更新两种形式，那么什么时候会同步更新，什么时候会异步更新呢？</p>
<p><strong>React控制之外的事件中调用setState是同步更新的。比如原生js绑定的事件，setTimeout&#x2F;setInterval等</strong>。</p>
<p><strong>大部分开发中用到的都是React封装的事件，比如onChange、onClick、onTouchMove等，这些事件处理程序中的setState都是异步处理的。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1.创建组件</span><br><span class="line">class St extends React.Component&#123;</span><br><span class="line">    //可以直接对其进行赋值</span><br><span class="line">    state = &#123;isHot:10&#125;;</span><br><span class="line">    render()&#123; //这个This也是实例对象</span><br><span class="line">        return &lt;h1 onClick = &#123;this.dem&#125;&gt;点击事件&lt;/h1&gt; </span><br><span class="line">    &#125;</span><br><span class="line">//箭头函数 [自定义方法---&gt;要用赋值语句的形式+箭头函数]</span><br><span class="line">    dem = () =&gt;&#123;</span><br><span class="line">        //修改isHot</span><br><span class="line">        this.setState(&#123; isHot: this.state.isHot + 1&#125;)</span><br><span class="line">        console.log(this.state.isHot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的案例中预期setState使得isHot变成了11，输出也应该是11。然而在控制台打印的却是10，也就是并没有对其进行更新。这是因为异步的进行了处理，在输出的时候还没有对其进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    document.getElementById(&quot;test&quot;).addEventListener(&quot;click&quot;,()=&gt;&#123;</span><br><span class="line">        this.setState(&#123;isHot: this.state.isHot + 1&#125;);</span><br><span class="line">        console.log(this.state.isHot);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是通过这个原生JS的，可以发现，控制台打印的就是11，也就是已经对其进行了处理。也就是进行了同步的更新。</p>
<p><strong>React怎么调用同步或者异步的呢？</strong></p>
<p>在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中延时更新，而 isBatchingUpdates 默认是 false，表示 setState 会同步更新 this.state；但是，有一个函数 batchedUpdates，该函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会先调用这个 batchedUpdates将isBatchingUpdates修改为true，这样由 React 控制的事件处理过程 setState 不会同步更新 this.state。</p>
<p><strong>如果是同步更新，每一个setState对调用一个render，并且如果多次调用setState会以最后调用的为准，前面的将会作废；如果是异步更新，多个setSate会统一调用一次render</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dem = () =&gt;&#123;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        isHot:  1,</span><br><span class="line">        cont:444</span><br><span class="line">    &#125;)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">    	isHot: this.state.isHot + 1</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">        isHot:  888,</span><br><span class="line">        cont:888</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的最后会输出：isHot是888，cont是888</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dem = () =&gt;&#123;</span><br><span class="line">               </span><br><span class="line">               this.setState(&#123;</span><br><span class="line">                   isHot: this.state.isHot + 1,</span><br><span class="line">                   </span><br><span class="line">               &#125;)</span><br><span class="line">               this.setState(&#123;</span><br><span class="line">                   isHot: this.state.isHot + 1,</span><br><span class="line">                   </span><br><span class="line">               &#125;)</span><br><span class="line">               this.setState(&#123;</span><br><span class="line">                   isHot: this.state.isHot + 888</span><br><span class="line">               &#125;)</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>

<p>初始isHot为10，最后isHot输出为898，也就是前面两个都没有执行。</p>
<p>**注意！！这是异步更新才有的，如果同步更新，每一次都会调用render，这样每一次更新都会 **</p>
<p><strong>简化版本：</strong></p>
<p>1.state的赋值可以不再构造函数中进行</p>
<p>2.使用了箭头函数，将this进行了改变</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 准备好容器 --&gt;</span><br><span class="line">    &lt;div id=&quot;test&quot;&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;!-- 引入依赖 ,引入的时候，必须就按照这个步骤--&gt;</span><br><span class="line">&lt;script src=&quot;../js/react.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;../js/react-dom.development.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script src=&quot;../js/babel.min.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">        class St extends React.Component&#123;</span><br><span class="line">            //可以直接对其进行赋值</span><br><span class="line">            state = &#123;isHot:true&#125;;</span><br><span class="line">            render()&#123; //这个This也是实例对象</span><br><span class="line">                return &lt;h1 onClick = &#123;this.dem&#125;&gt;今天天气很&#123;this.state.isHot?&quot;炎热&quot;:&quot;凉爽&quot;&#125;&lt;/h1&gt;    </span><br><span class="line">                //或者使用&#123;()=&gt;this.dem()也是可以的&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            //箭头函数 [自定义方法---&gt;要用赋值语句的形式+箭头函数]</span><br><span class="line">            dem = () =&gt;&#123;</span><br><span class="line">                console.log(this);</span><br><span class="line">                const state =  this.state.isHot;</span><br><span class="line">                this.setState(&#123;isHot:!state&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ReactDOM.render(&lt;St /&gt;,document.getElementById(&quot;test&quot;));       </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果想要在调用方法的时候传递参数，有两个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;</span><br><span class="line">&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>上述两种方式是等价的，分别通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>和 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><code>Function.prototype.bind</code></a> 来实现。</p>
<p>在这两种情况下，React 的事件对象 <code>e</code> 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 <code>bind</code> 的方式，事件对象以及更多的参数将会被隐式的进行传递。</p>
<h2 id="Props"><a href="#Props" class="headerlink" title="Props"></a>Props</h2><p>Props主要用来传递数据，比如组件之间进行传值</p>
<p>基本使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div id = &quot;div&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    class Person extends React.Component&#123;</span><br><span class="line">        render()&#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    //接受数据并显示</span><br><span class="line">                    &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //传递数据</span><br><span class="line">    ReactDOM.render(&lt;Person name=&quot;tom&quot; age = &quot;41&quot; sex=&quot;男&quot;/&gt;,document.getElementById(&quot;div&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>如果传递的数据是一个对象，可以更加简便的使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line">    class Person extends React.Component&#123;</span><br><span class="line">        render()&#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    const p = &#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;</span><br><span class="line">   ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&quot;div&quot;));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>… 这个符号恐怕都不陌生，这个是一个展开运算符，主要用来展开数组，如下面这个例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr1 = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</span><br><span class="line">arr2 = [...arr,...arr1];  <span class="comment">//arr2 = [1,2,,3,4,5,6]</span></span><br></pre></td></tr></table></figure>

<p>但是他还有其他的用法：</p>
<p>1.复制一个对象给另一个对象{…对象名}。此时这两个对象并没有什么联系了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;18&quot;</span>,<span class="attr">sex</span>:<span class="string">&quot;女&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = &#123;...p1&#125;;</span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&quot;sss&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2)  <span class="comment">//&#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>2.在复制的时候，合并其中的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>,<span class="attr">age</span>:<span class="string">&quot;18&quot;</span>,<span class="attr">sex</span>:<span class="string">&quot;女&quot;</span>&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = &#123;...p1,name : <span class="string">&quot;111&quot;</span>,<span class="attr">hua</span>:<span class="string">&quot;ss&quot;</span>&#125;;</span><br><span class="line">p1.<span class="property">name</span> = <span class="string">&quot;sss&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2)  <span class="comment">//&#123;name: &quot;111&quot;, age: &quot;18&quot;, sex: &quot;女&quot;,hua:&quot;ss&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>注意！！</strong> <strong>{…P}并不能展开一个对象</strong></p>
<p><strong>props传递一个对象，是因为babel+react使得{..p}可以展开对象，但是只有在标签中才能使用</strong></p>
<p><strong>对于props限制</strong></p>
<p>很多时候都想要传递的参数进行相应的限制，比如：限制传递参数的类型，参数的默认值等等</p>
<p>react对此提供了相应的解决方法：</p>
<ul>
<li>propTypes:类型检查，还可以限制不能为空</li>
<li>defaultProps：默认值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script type=&quot;text/babel&quot;&gt;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    class Person extends React.Component&#123;</span><br><span class="line">        render()&#123;</span><br><span class="line">            //props是只读的</span><br><span class="line">            return (</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.age&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;this.props.sex&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">        //对组件的属性对其进行限制</span><br><span class="line">        static propTypes = &#123;</span><br><span class="line">            name:PropTypes.string.isRequired, //限定name是string类型，并且必须要传递</span><br><span class="line">            sex:PropTypes.string,  //限定sex是string类型</span><br><span class="line">            speak:PropTypes.func   //限定speak是function类型</span><br><span class="line">        &#125;</span><br><span class="line">        //指定默认的标签属性</span><br><span class="line">        static defaultProps = &#123;</span><br><span class="line">            sex:&quot;不男不女&quot;,</span><br><span class="line">            age:18</span><br><span class="line">        &#125;   </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    //在js中可以使用&#123;...p&#125;来复制一个对象，但是这个地方并不是复制对象，而是babel+react通过展开运算符，展开了一个对象</span><br><span class="line">    //但是只能在标签中进行使用</span><br><span class="line">    //const p = &#123;name:&quot;张三&quot;,age:&quot;18&quot;,sex:&quot;女&quot;&#125;   &#123;14&#125;就代表的是数值</span><br><span class="line">    //ReactDOM.render(&lt;Person &#123;...p&#125;/&gt;,document.getElementById(&quot;div&quot;));</span><br><span class="line">    ReactDOM.render(&lt;Person name=&quot;sss&quot; age = &#123;14&#125; speak=&quot;8&quot;/&gt;,document.getElementById(&quot;div&quot;));</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    function speak()&#123;</span><br><span class="line">        console.log(&quot;这个是一个函数&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>函数式组件的使用</strong>：</p>
<p>函数在使用props的时候，是作为参数进行使用的(props)；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">function Person(props)&#123;</span><br><span class="line">          return (</span><br><span class="line">                &lt;ul&gt;</span><br><span class="line">                    &lt;li&gt;&#123;props.name&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;props.age&#125;&lt;/li&gt;</span><br><span class="line">                    &lt;li&gt;&#123;props.sex&#125;&lt;/li&gt;</span><br><span class="line">                &lt;/ul&gt;</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h2><p> Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。 </p>
<p>Refs主要提供了三种方式：</p>
<p><strong>1.字符串形式</strong></p>
<p>在想要获取到一个DOM节点，可以直接在这个节点上添加ref属性。利用该属性进行获取该节点的值。</p>
<p>案例：给需要的节点添加ref属性，此时该实例对象的refs上就会有这个值。就可以利用实例对象的refs获取已经添加节点的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input ref=&quot;dian&quot; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;</span><br><span class="line"></span><br><span class="line"> inputBlur = () =&gt;&#123;</span><br><span class="line">            alert(this.refs.shiqu.value);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.回调形式</strong></p>
<p>回调形式会在ref属性中添加一个回调函数。将该DOM作为参数传递过去。</p>
<p>如：ref里面就是一个回调函数，self就是该input标签。然后在将该DOM元素赋值给实例对象中的一个属性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input ref=&#123;self =&gt;&#123; this.dian = self;console.log(self)&#125;&#125;  placeholder=&quot;点击弹出&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/react/1611495051999.png" alt="input标签"></p>
<p>也可以将函数提取出来，在ref中进行调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isRef = (self) =&gt;&#123;</span><br><span class="line">            this.dian = self;</span><br><span class="line">            console.log(self)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&lt;input ref=&#123;this.isRef&#125; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p><strong>3.API形式</strong></p>
<p>React其实已经给我们提供了一个相应的API，他会自动的将该DOM元素放入实例对象中</p>
<p>如下：依旧先在DOM元素中添加一个ref元素</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;/*&lt;input ref=&#123;this.容器名称&#125; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;*/&#125;</span><br><span class="line">&lt;input ref=&#123;this.MyRef&#125; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;</span><br><span class="line">&lt;input ref=&#123;this.MyRef1&#125; type=&quot;text&quot; placeholder=&quot;点击弹出&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>通过API，创建React的容器，相当于省略了回调的中间环节。但是这个容器是专门专用的，所以每一个ref都需要创建这个。该API会将DOM元素赋值给实例对象的名称为容器名称的属性的current【这个current是固定的】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;/*容器名称 = React.createRef()*/&#125;</span><br><span class="line">MyRef = React.createRef();</span><br><span class="line">MyRef1 = React.createRef();</span><br></pre></td></tr></table></figure>

<p><img data-src="/images/react/1611495597978.png" alt="API"></p>
<p>然后就可以使用了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">btnOnClick = () =&gt;&#123;</span><br><span class="line">    //创建之后，将自身节点，传入current中</span><br><span class="line">    console.log(this.MyRef.current.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>官方提示我们不要过度的使用ref，如果发生时间的元素刚好是需要操作的元素，就可以使用事件去替代。</strong></p>
<h1 id="React事件"><a href="#React事件" class="headerlink" title="React事件"></a>React事件</h1><p>React的事件是通过onXxx属性指定事件处理函数</p>
<p>​        React使用的都是自定义的时间，而不是原生的事件</p>
<p>​        React中的事件是通过事件委托方式处理的</p>
<p>​		事件中必须返回的是函数</p>
<p>​        通过event.target得到发生事件的Dom元素对象</p>
<p>比如：</p>
<p>先声明一个事件，然后在根据事件创建相应的函数，根据事件的event参数，将DOM元素获取到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;input onChange=&#123;this.saveName&#125; type = &quot;text&quot; name =&quot;username&quot;/&gt;</span><br><span class="line"></span><br><span class="line">saveName = (event) =&gt;&#123;</span><br><span class="line">            this.setState(&#123;name:event.target.value&#125;);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p><strong>受控和非受控组件</strong></p>
<p>先来说说受控组件：</p>
<p> 使 React 的 state 成为“唯一数据源”。渲染表单的 React 组件还控制着用户输入过程中表单发生的操作。被 React 以这种方式控制取值的表单输入元素就叫做“受控组件”。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">saveName = (event) =&gt;&#123;</span><br><span class="line">    this.setState(&#123;name:event.target.value&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">savePwd = (event) =&gt; &#123;</span><br><span class="line">    this.setState(&#123;pwd:event.target.value&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;form action=&quot;http://www.baidu.com&quot; onSubmit=&#123;this.login&#125;&gt;</span><br><span class="line">            用户名：&lt;input value=&#123;this.state.name&#125; onChange=&#123;this.saveName&#125; type = &quot;text&quot; /&gt;</span><br><span class="line">            密码&lt;input value=&#123;this.state.pwd&#125; onChange=&#123;this.savePwd&#125; type = &quot;password&quot;/&gt;</span><br><span class="line">            &lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">        &lt;/form&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于在表单元素上设置了 <code>value</code> 属性，因此显示的值将始终为 <code>this.state.value</code>，这使得 React 的 state 成为唯一数据源。由于 <code>onchange</code> 在每次按键时都会执行并更新 React 的 state，因此显示的值将随着用户输入而更新。</p>
<p>对于受控组件来说，输入的值始终由 React 的 state 驱动。</p>
<p>非受控组件：</p>
<p>非受控组件其实就是表单元素的值不会更新state。输入数据都是现用现取的。</p>
<p>如下：下面并没有使用state来控制属性，使用的是事件来控制表单的属性值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Login extends React.Component&#123;</span><br><span class="line"></span><br><span class="line">    login = (event) =&gt;&#123;</span><br><span class="line">        event.preventDefault(); //阻止表单提交</span><br><span class="line">            console.log(this.name.value);</span><br><span class="line">            console.log(this.pwd.value);</span><br><span class="line">        &#125;</span><br><span class="line">        render() &#123;</span><br><span class="line">            return (</span><br><span class="line">                &lt;form action=&quot;http://www.baidu.com&quot; onSubmit=&#123;this.login&#125;&gt;</span><br><span class="line">                用户名：&lt;input ref = &#123;self =&gt; this.name =self &#125; type = &quot;text&quot; name =&quot;username&quot;/&gt;</span><br><span class="line">                密码：&lt;input ref = &#123;self =&gt; this.pwd =self &#125; type = &quot;password&quot; name =&quot;password&quot;/&gt;</span><br><span class="line">                &lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">                &lt;/form&gt;</span><br><span class="line">            )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>高级函数</strong></p>
<p>  1.如果函数的参数是函数</p>
<p>  2.如果函数返回一个函数</p>
<p><strong>函数的珂里化</strong></p>
<p>  通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式</p>
<p>如下，我们将上面的案例简化，创建高级函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Login extends React.Component&#123;</span><br><span class="line"></span><br><span class="line">       state = &#123;name:&quot;&quot;,pwd:&quot;&quot;&#125;;</span><br><span class="line">	</span><br><span class="line">	//返回一个函数</span><br><span class="line">       saveType = (type) =&gt;&#123;</span><br><span class="line">           return (event) =&gt; &#123;</span><br><span class="line">               this.setState(&#123;[type]:event.target.value&#125;);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //因为事件中必须是一个函数，所以返回的也是一个函数，这样就符合规范了</span><br><span class="line">       render() &#123;</span><br><span class="line">           return (</span><br><span class="line">               &lt;form&gt;</span><br><span class="line">     				&lt;input onChange = &#123;this.saveType(&#x27;name&#x27;)&#125; type = &quot;text&quot;/&gt;</span><br><span class="line">                   &lt;button&gt;登录&lt;/button&gt;</span><br><span class="line">               &lt;/form&gt;</span><br><span class="line">           )</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ReactDOM.render(&lt;Login /&gt;,document.getElementById(&quot;div&quot;));</span><br></pre></td></tr></table></figure>

<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h2 id="（旧）"><a href="#（旧）" class="headerlink" title="（旧）"></a>（旧）</h2><p>组件从创建到死亡，会经过一些特定的阶段</p>
<p>​      React组件中包含一系列钩子函数{生命周期回调函数}，会在特定的时刻调用</p>
<p>​      我们在定义组件的时候，会在特定的声明周期回调函数中，做特定的工作</p>
<p>如下图是旧生命周期的结构图：</p>
<p><img data-src="/images/react/1611490156766.png" alt="旧生命周期"></p>
<p>我们通过一个案例更详细的了解这个生命周期：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class A extends React.Component&#123;</span><br><span class="line"></span><br><span class="line">       constructor(props)&#123;</span><br><span class="line">           console.log(&quot;A --- constructor&quot;)</span><br><span class="line">           super(props);</span><br><span class="line">           this.state = &#123;num:1&#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       add = () =&gt; &#123;</span><br><span class="line">           let &#123;num&#125; = this.state;</span><br><span class="line">           this.setState(&#123;num:num+1&#125;);</span><br><span class="line">           //强制更新</span><br><span class="line">           //this.forceUpdate();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">      render()&#123;</span><br><span class="line">          console.log(&quot;A --- render&quot;);</span><br><span class="line">           return (</span><br><span class="line">               &lt;div&gt;</span><br><span class="line">                   &lt;h1&gt;这个是第&#123;this.state.num&#125;个&lt;/h1&gt;</span><br><span class="line">                   &lt;B name = &#123;this.state.num&#125;/&gt;</span><br><span class="line">                   &lt;button onClick = &#123;this.add&#125;&gt;点击加一&lt;/button&gt;</span><br><span class="line">               &lt;/div&gt;</span><br><span class="line">           )</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //在render之前执行</span><br><span class="line">      componentWillMount()&#123;</span><br><span class="line">           console.log(&quot;A --- componentWillMount&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //在render之后执行</span><br><span class="line">      componentDidMount()&#123;</span><br><span class="line">       console.log(&quot;A --- componenetDidMount&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //更新操作 setState之后执行，判断是否可以更新（true可以，false不可以）</span><br><span class="line">      shouldComponentUpdate()&#123;</span><br><span class="line">           console.log(&quot;A --- shouldComponentUpdate&quot;);</span><br><span class="line">           return true;</span><br><span class="line">      &#125;</span><br><span class="line">      // 组件将要更新之前</span><br><span class="line">      componentWillUpdate()&#123;</span><br><span class="line">           console.log(&quot;A --- componentWillUpdate&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      //组件更新之后，该函数可以接受相应的参数</span><br><span class="line">      componentDidUpdate()&#123;</span><br><span class="line">           console.log(&quot;A --- componentDidUpdate&quot;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //卸载组件之后</span><br><span class="line">      componentWillUnmonut()&#123;</span><br><span class="line">           console.log(&quot;A --- componentWillUnmonut&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  class B extends React.Component&#123;</span><br><span class="line">      render()&#123;</span><br><span class="line">          return(   </span><br><span class="line">               &lt;div&gt;</span><br><span class="line">                   &lt;h1&gt;这个是B组件,传递过来的是：&#123;this.props.name&#125;&lt;/h1&gt;</span><br><span class="line">               &lt;/div&gt;</span><br><span class="line">          )</span><br><span class="line">      &#125;</span><br><span class="line">      //父组件进行了更新，子组件先执行这个【注意，第一次传递数据的时候，并不执行】</span><br><span class="line">      componentWillReceiveProps()&#123;</span><br><span class="line">       console.log(&quot;A --- componentWillReceiveProps&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">   ReactDOM.render(&lt;A   /&gt;,document.getElementById(&quot;div&quot;));</span><br></pre></td></tr></table></figure>

<p>我们在控制台看一下：</p>
<p>当我们刚刚打开控制台的时候，组件第一次加载：</p>
<p><img data-src="/images/react/1611568192158.png" alt="组件第一次加载"></p>
<p>当我们点击按钮更新sate的时候：</p>
<p><img data-src="/images/react/1611568250881.png" alt="更新state"></p>
<h2 id="（新）"><a href="#（新）" class="headerlink" title="（新）"></a>（新）</h2><p>在最新的react版本中，有些生命周期钩子被抛弃了，在官网中是这样说的：</p>
<p>我们得到最重要的经验是，过时的组件生命周期往往会带来不安全的编码实践，具体函数如下：</p>
<ul>
<li><code>componentWillMount</code></li>
<li><code>componentWillReceiveProps</code></li>
<li><code>componentWillUpdate</code></li>
</ul>
<p>这些生命周期方法经常被误解和滥用；此外，我们预计，在异步渲染中，它们潜在的误用问题可能更大。我们将在即将发布的版本中为这些生命周期添加 “UNSAFE_” 前缀。（这里的 “unsafe” 不是指安全性，而是表示使用这些生命周期的代码在 React 的未来版本中更有可能出现 bug，尤其是在启用异步渲染之后。）</p>
<p>由此可见，新版本中并不推荐持有这三个函数，取而代之的是带有UNSAFE_ 前缀的三个函数，比如: UNSAFE_ componentWillMount。即便如此，其实React官方还是不推荐大家去使用，在以后版本中有可能会去除这几个函数。</p>
<p>如下图是新的生命周期：</p>
<p><img data-src="/images/react/1611651795885.png" alt="新生命周期"></p>
<p>从图上可以看出，新生命周期和旧生命周期的区别主要有：</p>
<p>1.抛弃了上面所说的三个钩子函数【其实还可以使用】</p>
<p>2.新添加了两个钩子函数</p>
<p>现在重点说一下，新添加的钩子函数</p>
<p><strong>static getDerivedStateFromProps(props, state)</strong></p>
<p>首先，该函数会调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用；该函数必须是静态的；给组件传递的数据（props）以及组件状态（state），会作为参数到这个函数中；该函数也必须有返回值，返回一个Null或者state对象。因为初始化和后续更新都会执行这个方法，因此在这个方法返回state对象，就相当于将原来的state进行了覆盖，所以倒是修改状态不起作用。</p>
<p><strong>getSnapshotBeforeUpdate(prevProps, prevState)</strong></p>
<p> <code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。此生命周期的任何返回值将作为参数传递<code>componentDidUpdate()</code>。 </p>
<blockquote>
<p>补充一下：componentDidUpdate(prevProps, prevState, snapshot)</p>
<p>该生命周期函数，可以有三个参数：原始传过来的参数，最开始的状态，getSnapshotBeforeUpdate传递的值</p>
<p>关于更多关于生命周期的介绍，可以参考官方文档：</p>
<p><a href="https://zh-hans.reactjs.org/docs/react-component.html#render">https://zh-hans.reactjs.org/docs/react-component.html#render</a></p>
</blockquote>
<p>以上就是两个新添加的钩子函数，但是在现实开发中可能并不常用这两个。</p>
<p>**案例：在一个区域内，定时的输出以行话，如果内容大小超过了区域大小，就出现滚动条，但是内容不进行移动 **</p>
<p><img data-src="/images/react/BeforeGender.gif" alt="案例"></p>
<p>如上面的动图：区域内部的内容展现没有变化，但是可以看见滚动条在变化，也就是说上面依旧有内容在输出，只不过不在这个区域内部展现。</p>
<p><strong>实现：</strong></p>
<p>【一些css样式，就不在这展示了】</p>
<p>1.首先我们先实现定时输出内容</p>
<p>我们可以使用state状态，改变新闻后面的值，但是为了同时显示这些内容，我们应该为state的属性定义一个数组。并在创建组件之后开启一个定时器，不断的进行更新state。更新渲染组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class New extends React.Component&#123;</span><br><span class="line"></span><br><span class="line">       state = &#123;num:[]&#125;;</span><br><span class="line"></span><br><span class="line">       //在组件创建之后,开启一个定时任务</span><br><span class="line">       componentDidMount()&#123;</span><br><span class="line">           setInterval(()=&gt;&#123;</span><br><span class="line">               let &#123;num&#125; = this.state;</span><br><span class="line">               const news = (num.length+1);</span><br><span class="line">               this.setState(&#123;num:[news,...num]&#125;);</span><br><span class="line">           &#125;,2000);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       render()&#123;</span><br><span class="line">           return (</span><br><span class="line"></span><br><span class="line">               &lt;div ref = &quot;list&quot; className = &quot;list&quot;&gt;&#123;</span><br><span class="line">                   this.state.num.map((n,index)=&gt;&#123;</span><br><span class="line">                   return &lt;div className=&quot;news&quot; key=&#123;index&#125; &gt;新闻&#123;n&#125;&lt;/div&gt;</span><br><span class="line">                   &#125;)</span><br><span class="line">               &#125;&lt;/div&gt;</span><br><span class="line">           )</span><br><span class="line">       &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> ReactDOM.render(&lt;New /&gt;,document.getElementById(&quot;div&quot;));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2.接下来就是控制滚动条了</p>
<p>我们在组件渲染到DOM之前获取组件的高度，然后用组件渲染之后的高度减去之前的高度就是一条新的内容的高度，这样在不断的累加到滚动条位置上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getSnapshotBeforeUpdate()&#123;</span><br><span class="line">	return this.refs.list.scrollHeight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentDidUpdate(preProps,preState,height)&#123;</span><br><span class="line">	this.refs.list.scrollTop += (this.refs.list.scrollHeight - height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就实现了这个功能。</p>
<h1 id="Diff算法"><a href="#Diff算法" class="headerlink" title="Diff算法"></a>Diff算法</h1><p>提到这个算法，就必须说一下关于Key的事情了。</p>
<p>其实每个组件中的每个标签都会有一个key,只不过有的必须显示的指定，有的可以隐藏。</p>
<p> 如果生成的render出来后就不会改变里面的内容，那么你不需要指定key（不指定key时，React也会生成一个默认的标识）,或者将index作为key，只要key不重复即可。</p>
<p>但是如果你的标签是动态的，是有可能刷新的，就必须显示的指定key。必须上面案使用map进行便利的时候就必须指定Key:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.state.num.map((n,index)=&gt;&#123;</span><br><span class="line">	return &lt;div className=&quot;news&quot; key=&#123;index&#125; &gt;新闻&#123;n&#125;&lt;/div&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这个地方虽然显示的指定了key，但是<strong>官网并不推荐使用Index作为Key去使用</strong>；</p>
<p>这样会很有可能会有效率上的问题</p>
<p>举个例子：</p>
<p>在一个组件中，我们先创建了两个对象，通过循环的方式放入&lt; li&gt;标签中，此时key使用的是index。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">person:[</span><br><span class="line">    &#123;id:1,name:&quot;张三&quot;,age:18&#125;,</span><br><span class="line">    &#123;id:2,name:&quot;李四&quot;,age:19&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">this.state.person.map((preson,index)=&gt;&#123;</span><br><span class="line">  return  &lt;li key = &#123;index&#125;&gt;&#123;preson.name&#125;&lt;/li&gt;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如下图展现在页面中：</p>
<p><img data-src="/images/react/1611800406864.png" alt="原始对象数组"></p>
<p>此时，我们想在点击按钮之后动态的添加一个对象，并且放入到li标签中，在重新渲染到页面中。</p>
<p>我们通过修改State来控制对象的添加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;button onClick=&#123;this.addObject&#125;&gt;点击增加对象&lt;/button&gt;</span><br><span class="line">addObject = () =&gt;&#123;</span><br><span class="line">    let &#123;person&#125; = this.state;</span><br><span class="line">    const p = &#123;id:(person.length+1),name:&quot;王五&quot;,age:20&#125;;</span><br><span class="line">    this.setState(&#123;person:[p,...person]&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下动图所示：</p>
<p> <img data-src="/images/react/addObject.gif" alt="原始对象数组"> </p>
<p>这样看，虽然完成了功能。但是其实存在效率上的问题，	我们先来看一下两个前后组件状态的变化：</p>
<p><img data-src="/images/react/1611800988496.png" alt="组件状态的变化"></p>
<p>我们发现，组件第一个变成了王五，张三和李四都移下去了。因为我们使用Index作为Key，这三个标签的key也就发生了改变【张三原本的key是0，现在变成了1，李四的key原本是1，现在变成了2，王五变成了0】在组件更新状态重新渲染的时候，就出现了问题：</p>
<p>因为react是通过key来比较组件标签是否一致的，拿这个案例来说：</p>
<p>首先，状态更新导致组件标签更新，react根据Key，判断旧的虚拟DOM和新的虚拟DOM是否一致</p>
<p>key &#x3D; 0 的时候 旧的虚拟DOM 内容是张三  新的虚拟DOM为王五 ，react认为内容改变，从而重新创建新的真实DOM.</p>
<p>key &#x3D; 1 的时候 旧的虚拟DOM 内容是李四，新的虚拟DOM为张三，react认为内容改变，从而重新创建新的真实DOM</p>
<p>key &#x3D; 2 的时候 旧的虚拟DOM没有，创建新的真实DOM </p>
<p>这样原本有两个虚拟DOM可以复用，但都没有进行复用，完完全全的都是新创建的；这就导致效率极大的降低。</p>
<p>其实这是因为我们将新创建的对象放在了首位，如果放在最后其实是没有问题的，但是因为官方并不推荐使用Index作为key值，我们推荐使用id作为key值。从而完全避免这样的情况。</p>
<p><strong>用index作为key可能会引发的问题:</strong></p>
<p>1。若对数据进行:逆序添加、逆序删除等破坏顺序操作:</p>
<p>​		会产生没有必要的真实DOM更新  界面效果没问题,但效率低。</p>
<p>2．如果结构中还包含输入类的DOM:</p>
<p>​        会产生错误DOM更新   界面有问题。</p>
<p>3，注意! 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。</p>
<p><strong>开发如何选择key?</strong></p>
<p>最好使用每一条数据的唯一标识作为key 比如id，手机号，身份证号</p>
<p>如果确定只是简单的展示数据，用Index也是可以的</p>
<p><strong>而这个判断key的比较规则就是Diff算法</strong></p>
<p>Diff算法其实就是react生成的新虚拟DOM和以前的旧虚拟DOM的比较规则：</p>
<ul>
<li><p>如果旧的虚拟DOM中找到了与新虚拟DOM相同的key:</p>
<ul>
<li>如果内容没有变化，就直接只用之前旧的真实DOM</li>
<li>如果内容发生了变化，就生成新的真实DOM</li>
</ul>
<p>			</p>
</li>
<li><p>如果旧的虚拟DOM中没有找到了与新虚拟DOM相同的key:</p>
<ul>
<li>根据数据创建新的真实的DOM,随后渲染到页面上</li>
</ul>
</li>
</ul>
<h1 id="React脚手架"><a href="#React脚手架" class="headerlink" title="React脚手架"></a>React脚手架</h1><p>react提供了一个用于创建react项目的脚手架库：create-react-app</p>
<h2 id="创建项目并启动"><a href="#创建项目并启动" class="headerlink" title="创建项目并启动"></a>创建项目并启动</h2><p>1.全局安装：npm i -g create-react-app</p>
<p>2.创建项目：create-react-app 项目名  </p>
<p>在这一步，有可能会出现：</p>
<p><img data-src="/images/react/1611803687193.png" alt="不是内部命令"></p>
<p>这样可以直接使用：npx create-react-app 项目名 </p>
<p>3.等待下载完成，进入项目文件夹，运行一下</p>
<p>比如，我这的项目名称是hello,就先进入hello文件夹</p>
<p>cd hello</p>
<p>npm start   &#x2F;&#x2F;启动这个项目</p>
<p><img data-src="/images/react/1611816095069.png" alt="启动成功"></p>
<p>这个时会自动的打开浏览器，展现这个项目：</p>
<p><img data-src="/images/react/1611816150630.png" alt="第一个脚手架项目"></p>
<h2 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h2><p>我们先来看一下public这个目录下面的结构：</p>
<p><img data-src="/images/react/1611817630266.png" alt="public"></p>
<p>这里面最主要的还是这个Index.html文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;utf-8&quot; /&gt;</span><br><span class="line">    &lt;!--%PUBLIC_URL%表示public文件夹的路径--&gt;</span><br><span class="line">    &lt;link rel=&quot;icon&quot; href=&quot;%PUBLIC_URL%/favicon.ico&quot; /&gt;</span><br><span class="line">    &lt;!--用于开启理想视口，用于移动端页面的适配--&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</span><br><span class="line">    &lt;!--用于配置浏览器地址栏的颜色（仅支持安卓手机浏览器）--&gt;</span><br><span class="line">    &lt;meta name=&quot;theme-color&quot; content=&quot;#000000&quot; /&gt;</span><br><span class="line">    &lt;!--描述网页信息的--&gt;</span><br><span class="line">    &lt;meta</span><br><span class="line">      name=&quot;description&quot;</span><br><span class="line">      content=&quot;Web site created using create-react-app&quot;</span><br><span class="line">    /&gt;</span><br><span class="line">    &lt;!--用于指定网页添加到手机主屏幕后的图标（仅仅支持ios）--&gt;</span><br><span class="line">    &lt;link rel=&quot;apple-touch-icon&quot; href=&quot;%PUBLIC_URL%/logo192.png&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;!--应用加壳时候的配置文件 --&gt;</span><br><span class="line">    &lt;link rel=&quot;manifest&quot; href=&quot;%PUBLIC_URL%/manifest.json&quot; /&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;title&gt;React App&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;!-- 浏览器不支持JS的运行的时候展现 --&gt;</span><br><span class="line">    &lt;noscript&gt;You need to enable JavaScript to run this app.&lt;/noscript&gt;</span><br><span class="line">    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>src文件：</p>
<p><img data-src="/images/react/1611818262317.png" alt="src文件"></p>
<p>这里面其实最主要的就是App.js以及index.js，一个是组件，一个是将组件渲染到页面中的。</p>
<h2 id="第一个脚手架应用"><a href="#第一个脚手架应用" class="headerlink" title="第一个脚手架应用"></a>第一个脚手架应用</h2><p>1.我们保持public中的Index.html不变</p>
<p>2.修改src下面的APP.js以及index.js文件</p>
<p>App.js:  【注意：创建好的组件一定要暴露出去】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//创建外壳组件APP</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">class App extends React.Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;Hello word&lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App</span><br></pre></td></tr></table></figure>

<p>index.js: 【主要的作用其实就是将App这个组件渲染到页面上】</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//引入核心库</span><br><span class="line">import React from &#x27;react&#x27;</span><br><span class="line">import ReactDOM from &#x27;react-dom&#x27;</span><br><span class="line">//引入组件</span><br><span class="line">import App from &#x27;./App&#x27;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(&lt;App /&gt;,document.getElementById(&quot;root&quot;))</span><br></pre></td></tr></table></figure>

<p>这样在重新启动应用，就成功了。</p>
<p><img data-src="/images/react/1611820194124.png" alt="第一个脚手架应用"></p>
<p>我们也不建议这样直接将内容放入App组件中，尽量还是用内部组件。</p>
<p>我们在顶一个Hello组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React,&#123;Componet&#125; from &#x27;react&#x27;</span><br><span class="line"></span><br><span class="line">export default class Hello extends Componet&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1&gt;Hello&lt;/h1&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在App组件中，进行使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class App extends Component&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;Hello /&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的结果和前面是一样的。</p>
<p>但是由于普通的Js和组件都是js，所一最好组件使用jsx去展示。</p>
<h2 id="样式冲突"><a href="#样式冲突" class="headerlink" title="样式冲突"></a>样式冲突</h2><p>当组件逐渐增多起来的时候，我们发现，组件的样式也是越来越丰富，这样就很有可能产生两个组件中样式名称有可能会冲突，这样会根据引入App这个组件的先后顺序，后面的会覆盖前面的，</p>
<p>为了避免这样的样式冲突，我们采用下面的形式：</p>
<p>1.将css文件名修改： hello.css — &gt;hello.module.css</p>
<p>2.引入并使用的时候改变方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import React,&#123;Component&#125;from &#x27;react&#x27;</span><br><span class="line">import hello from &#x27;./hello.module.css&#x27;  //引入的时候给一个名称</span><br><span class="line"></span><br><span class="line">export default class Hello extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;h1 className=&#123;hello.title&#125;&gt;Hello&lt;/h1&gt;   //通过大括号进行调用</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="功能界面的组件化编码流程"><a href="#功能界面的组件化编码流程" class="headerlink" title="功能界面的组件化编码流程"></a>功能界面的组件化编码流程</h1><p>1.拆分组件:拆分界面，抽取组件</p>
<p>2.实现静态组件</p>
<p>3.实现动态组件</p>
<ul>
<li>动态的显示初始化数据<ul>
<li>数据类型</li>
<li>数据名称</li>
<li>保存在哪个组件</li>
</ul>
</li>
<li>交互</li>
</ul>
<p><strong>注意事项：</strong></p>
<p>1.拆分组件、实现静态组件。注意className、style的写法</p>
<p>2.动态初始化列表，如何确定将数据放在哪个组件的state中？</p>
<ul>
<li>某个组件使用：放在自身的state中</li>
<li>某些组件使用：放在他们共同的父组件中【状态提升】</li>
</ul>
<p>3.关于父子组件之间的通信</p>
<ul>
<li>父组件给子组件传递数据：通过props传递</li>
<li>子组件给父组件传递数据：通过props传递，要求父组件提前给子组件传递一个函数</li>
</ul>
<p>4.注意defaultChecked 和checked区别，defalutChecked只是在初始化的时候执行一次，checked没有这个限制，但是必须添加onChange方法类似的还有：defaultValue 和value</p>
<p>5.状态在哪里，操作状态的方法就在哪里</p>
<h1 id="react-ajax"><a href="#react-ajax" class="headerlink" title="react ajax"></a>react ajax</h1><p>React本身只关注与页面，并不包含发送ajax请求的代码，所以一般都是集成第三方的一些库，或者自己进行封装。</p>
<p>推荐使用axios。</p>
<p>在使用的过程中很有可能会出现跨域的问题，这样就应该配置代理。</p>
<p> 所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port）， 当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域  。</p>
<p>那么react通过代理解决跨域问题呢</p>
<p><strong>方法一</strong></p>
<blockquote>
<p>在package.json中追加如下配置</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;proxy&quot;</span><span class="punctuation">:</span><span class="string">&quot;请求的地址&quot;</span>      <span class="attr">&quot;proxy&quot;</span><span class="punctuation">:</span><span class="string">&quot;http://localhost:5000&quot;</span>  </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li>优点：配置简单，前端请求资源时可以不加任何前缀。</li>
<li>缺点：不能配置多个代理。</li>
<li>工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）</li>
</ol>
<p><strong>方法二</strong></p>
<ol>
<li><p>第一步：创建代理配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在src下创建配置文件：src/setupProxy.js</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写setupProxy.js配置具体代理规则：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> proxy = <span class="built_in">require</span>(<span class="string">&#x27;http-proxy-middleware&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span>(<span class="params">app</span>) &#123;</span><br><span class="line">  app.<span class="title function_">use</span>(</span><br><span class="line">    <span class="title function_">proxy</span>(<span class="string">&#x27;/api1&#x27;</span>, &#123;  <span class="comment">//api1是需要转发的请求(所有带有/api1前缀的请求都会转发给5000)</span></span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>, <span class="comment">//配置转发目标地址(能返回数据的服务器地址)</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">//控制服务器接收到的请求头中host字段的值</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      	changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000</span></span><br><span class="line"><span class="comment">      	changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:3000</span></span><br><span class="line"><span class="comment">      	changeOrigin默认值为false，但我们一般将changeOrigin值设为true</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api1&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125; <span class="comment">//去除请求前缀，保证交给后台服务器的是正常请求地址(必须配置)</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="title function_">proxy</span>(<span class="string">&#x27;/api2&#x27;</span>, &#123; </span><br><span class="line">      <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123;<span class="string">&#x27;^/api2&#x27;</span>: <span class="string">&#x27;&#x27;</span>&#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>说明：</p>
<ol>
<li>优点：可以配置多个代理，可以灵活的控制请求是否走代理。</li>
<li>缺点：配置繁琐，前端请求资源时必须加前缀。</li>
</ol>
<h1 id="兄弟之间进行通信"><a href="#兄弟之间进行通信" class="headerlink" title="兄弟之间进行通信"></a>兄弟之间进行通信</h1><p>这就要借助消息订阅和发布机制。</p>
<p>举个例子来说就是张三想要跟李四进行通信，张三就需要订阅一个消息【比如A消息】，李四想要给张三数据，就必须发布一个A消息，在发布的同时将数据放入消息中，因为张三订阅了名称为A的消息，此时就能接受到李四发布的消息，从而获取到数据。</p>
<p>这就有点类似于看报纸，甲想要知道每天都发生什么事情，于是订阅了每天日报，乙每天都会发布这个每天日报，因为甲订阅了，于是乙就会每天就给甲方推送，甲方从而获取数据。</p>
<p><strong>在消息订阅和发布中，我们可以使用PubSubJs进行通信：</strong></p>
<p>引入PubSubJs:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import PubSub from &#x27;pubsub-js&#x27;</span><br></pre></td></tr></table></figure>

<p>订阅消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PubSub.subscribe(&quot;getSate&quot;,(_,data)=&gt;&#123;</span><br><span class="line">            console.log(data)</span><br><span class="line">        &#125;)</span><br><span class="line">PubSub.subscribe(&quot;订阅的消息名称&quot;,回调函数，第一个参数是消息名称，可以使用_来占位，第二个是传递的数据</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>发布消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PubSub.publish(&quot;getSate&quot;,&#123;isFrist:false,isLoad:true&#125;)</span><br><span class="line">PubSub.publish(&quot;订阅的消息名称&quot;,传递的数据)</span><br></pre></td></tr></table></figure>

<h1 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h1><p><strong>async:</strong></p>
<p>该关键字是放在函数之前的，使得函数成为一个异步函数，他最大的特点就是将函数回封装成Promise，也就是被他修饰的函数的返回值都是Promise对象。而这个Promise对象的状态则是由函数执行的返回值决定的。</p>
<p>如果返回的是一个非promise对象，该函数将返回一个成功的Promise，成功的值则是返回的值；</p>
<p>如果返回的是一个promise对象，则该函数返回的就是该promise对应的状态。</p>
<p><strong>await</strong></p>
<p>await右边是一个表达式，如果该表达式返回的是一个Promise对象，则左边接收的结果就是该Promise对象成功的结果，如果该Promise对象失败了，就必须使用try..catch来捕获。如果该表达式返回的是是一个不是promise对象，则左边接受的就是该表达式的返回值。</p>
<p> 当 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await">await</a> 关键字与异步函数一起使用时，它的真正优势就变得明显了 —— 事实上， <strong>await 只在异步函数里面才起作用</strong>。它可以放在任何异步的，基于 promise 的函数之前。它会暂停代码在该行上，直到 promise 完成，然后返回结果值。在暂停的同时，其他正在等待执行的代码就有机会执行了。 </p>
<p>举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f1 = () =&gt;&#123;</span><br><span class="line">       return new Promise((resolve,reject)=&gt;&#123;</span><br><span class="line">           // resolve(1);</span><br><span class="line">           reject(&quot;错误&quot;)</span><br><span class="line">       &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   async function test()&#123;</span><br><span class="line">       try&#123;</span><br><span class="line">          const p =  await f1();</span><br><span class="line">          console.log(p)</span><br><span class="line">       &#125;catch(error)&#123;</span><br><span class="line">           console.error(error)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   test();</span><br></pre></td></tr></table></figure>

<h1 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h1><p>以前发送请求，使用ajax或者axios，现在还可以使用fetch。这个是window自带的，和xhr是一个级别的。</p>
<p>可以查看这个文章，写的真的不错：</p>
<p><a href="http://www.ruanyifeng.com/blog/2020/12/fetch-tutorial.html">fetch</a></p>
<h1 id="React路由"><a href="#React路由" class="headerlink" title="React路由"></a>React路由</h1><h2 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h2><p>单页Web应用(single page web application，SPA)。整个应用只有一个完整的页面。</p>
<p>点击页面中的链接不会刷新页面，只会做页面的局部更新。</p>
<p>数据都需要通过ajax请求获取,并在前端异步展现</p>
<h2 id="什么是路由"><a href="#什么是路由" class="headerlink" title="什么是路由"></a>什么是路由</h2><p>一个路由其实就是一个映射关系（k:v）</p>
<p>key为路径，value可能是function 或者是 component</p>
<p><strong>后端路由：</strong></p>
<p>value是function，用来处理客户端提交的请求</p>
<p>注册路由：router.get(path,function(req,res))</p>
<p>工作过程：当node接收一个请求的时候，根据请求路径找到匹配的路由，调用路由中的函数来处理请求，返回响应的数据</p>
<p><strong>前端路由：</strong></p>
<p>浏览器端路由，value是Component，用于展示页面内容</p>
<p>注册路由：&lt; Route path&#x3D;”&#x2F;test” component&#x3D;{Test}&gt;</p>
<p>工作过程：当浏览器的path变为&#x2F;test的时候，当前路由组件就会变成Test组件</p>
<p><strong>前端路由的原理</strong></p>
<p>这个主要是依靠于history，也就是浏览器的历史记录。</p>
<p>浏览器上的记录其实就是一个栈，前进一次就是入栈，后退一次就是出栈。</p>
<p>并且历史记录上有一个监听的方法，可以时时刻刻监听记录的变化。从而判断是否改变路径</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/History">History</a></p>
<h2 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h2><p>react的路由有三类：</p>
<p>web【主要适用于前端】,native【主要适用于本地】,anywhere【任何地方】</p>
<p>在这主要使用web也就是这个标题 react-router-dom</p>
<p><strong>基本的使用：</strong></p>
<p>导航中的a标签改写成Link标签</p>
<p>&lt; Link to&#x3D;”&#x2F;路径” &gt;xxx&lt; &#x2F;Link&gt;</p>
<p>展示区写Route标签进行路径的匹配</p>
<p>&lt; Route path &#x3D; ‘&#x2F;路径’ component&#x3D;{组件名称}&gt;</p>
<p>&lt; App&gt;最外侧包裹了一个&lt; BrowserRouter&gt;或者&lt; HashRouter&gt;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div className=&quot;list-group&quot;&gt;</span><br><span class="line">    &lt;Link className=&quot;list-group-item&quot;  to=&quot;/about&quot;&gt;About&lt;/Link&gt;</span><br><span class="line">    &lt;Link className=&quot;list-group-item&quot;  to=&quot;/home&quot;&gt;Home&lt;/Link&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;div className=&quot;panel-body&quot;&gt;</span><br><span class="line">    &#123;/* 注册路由，也就是写对应的关系 */&#125;</span><br><span class="line">    &lt;Route path=&quot;/about&quot;component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;Route path=&quot;/home&quot;component=&#123;Home&#125;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">index.js:</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;BrowserRouter&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/BrowserRouter&gt;</span><br><span class="line">    ,document.getElementById(&quot;root&quot;))</span><br></pre></td></tr></table></figure>

<p>那么使用Link代替a标签之后，在页面上会是什么呢，我们发现其实页面上也是把link转化为了a标签</p>
<p><strong>路由组件以及一般组件</strong></p>
<p>1.写法不一样</p>
<p>一般组件：&lt; Demo&gt;</p>
<p>路由组件：&lt; Route path&#x3D;”&#x2F;demo” component &#x3D;{Demo}&#x2F;&gt;</p>
<p>2.存放的位置一般不同</p>
<p>一般组件：components</p>
<p>路由组件：pages</p>
<p>3.接收的内容【props】</p>
<p>一般组件：写组件标签的时候传递什么，就能收到什么</p>
<p>路由组件：接收到三个固定的属性【history,location,match】</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">history</span>:</span><br><span class="line">    <span class="attr">go</span>: ƒ <span class="title function_">go</span>(n)</span><br><span class="line">    <span class="attr">goBack</span>: ƒ <span class="title function_">goBack</span>()</span><br><span class="line">    <span class="attr">goForward</span>: ƒ <span class="title function_">goForward</span>()</span><br><span class="line">    <span class="attr">push</span>: ƒ <span class="title function_">push</span>(path, state)</span><br><span class="line">    <span class="attr">replace</span>: ƒ <span class="title function_">replace</span>(path, state)</span><br><span class="line"><span class="attr">location</span>:</span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&quot;/about&quot;</span></span><br><span class="line">    <span class="attr">search</span>: <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">state</span>: <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line"><span class="attr">match</span>:</span><br><span class="line">    <span class="attr">params</span>: &#123;&#125;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">&quot;/about&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>NavLink</strong></p>
<p>因为Link不能够改变标签体，因此只适合用于一些写死的标签。而如果想要有一些点击的效果，使用NavLink.</p>
<p>如下代码，就写了ctiveClassName，当点击的时候就会触发这个class的样式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;/*NavLink在点击的时候就会去找activeClassName=&quot;ss&quot;所指定的class的值，如果不添加默认是active</span><br><span class="line"> 这是因为Link相当于是把标签写死了，不能去改变什么。*/&#125;</span><br><span class="line"></span><br><span class="line">&lt;NavLink  ctiveClassName=&quot;ss&quot; className=&quot;list-group-item&quot;  to=&quot;/about&quot;&gt;About&lt;/NavLink&gt;</span><br><span class="line">&lt;NavLink className=&quot;list-group-item&quot;  to=&quot;/home&quot;&gt;Home&lt;/NavLink&gt; </span><br></pre></td></tr></table></figure>

<p>但是可能一个导航又很多标签，如果这样重复的写NavLink也会造成很多的重复性的代码问题。</p>
<p>因此可以自定义一个NavLink：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // 通过&#123;...对象&#125;的形式解析对象，相当于将对象中的属性全部展开</span><br><span class="line"> //&lt;NavLink  to = &#123;this.props.to&#125; children = &#123;this.props.children&#125;/&gt;</span><br><span class="line">&lt;NavLink className=&quot;list-group-item&quot; &#123;...this.props&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>​	在使用的时候：直接写每个标签中不一样的部分就行，比如路径和名称</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;/*将NavLink进行封装，成为MyNavLink,通过props进行传参数，标签体内容props是特殊的一个属性，叫做children */&#125;</span><br><span class="line">&lt;MyNavLink to = &quot;/about&quot; &gt;About&lt;/MyNavLink&gt;</span><br></pre></td></tr></table></figure>

<h2 id="样式错误"><a href="#样式错误" class="headerlink" title="样式错误"></a>样式错误</h2><p>拿上面的案例来说：</p>
<p>这里面会有一个样式：</p>
<p><img data-src="/images/react/1612316916900.png" alt="样式表"></p>
<p>此时，加载该样式的路径为：</p>
<p><img data-src="/images/react/1612317786643.png" alt="加载样式路径"></p>
<p>但是在写路由的时候，有的时候就会出现多级目录，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MyNavLink to = &quot;/cyk/about&quot; &gt;About&lt;/MyNavLink&gt;</span><br><span class="line"></span><br><span class="line">&lt;Route path=&quot;/cyk/about&quot;component=&#123;About&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>这个时候就在刷新页面，就会出现问题：</p>
<p>样式因为路径问题加载失败，此时页面返回public下面的Index.html</p>
<p><img data-src="/images/react/1612317880916.png" alt="加载页面失败"></p>
<p>解决这个问题，有三个方法：</p>
<p>1.样式加载使用绝对位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt; </span><br></pre></td></tr></table></figure>

<p>2.使用 %PUBLIC_URL%</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;link href=&quot;%PUBLIC_URL%/css/bootstrap.css&quot; rel=&quot;stylesheet&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>3.使用HashRouter</p>
<p>因为HashRouter会添加#，默认不会处理#后面的路径，所以也是可以解决的</p>
<h2 id="模糊匹配和精准匹配"><a href="#模糊匹配和精准匹配" class="headerlink" title="模糊匹配和精准匹配"></a>模糊匹配和精准匹配</h2><p>react默认是开启模糊匹配的。</p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MyNavLink to = &quot;/home/a/b&quot; &gt;Home&lt;/MyNavLink&gt;</span><br></pre></td></tr></table></figure>

<p>此时该标签匹配的路由，分为三个部分 home a b；将会根据这个先后顺序匹配路由。</p>
<p>如下就可以匹配到相应的路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Route path=&quot;/home&quot;component=&#123;Home&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>但是如果是下面这个就会失败，也就是说他是根据路径一级一级查询的，可以包含前面那一部分，但并不是只包含部分就可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Route path=&quot;/a&quot; component=&#123;Home&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>当然也可以使用这个精确的匹配 exact&#x3D;{true}</p>
<p>如以下：这样就精确的匹配&#x2F;home，则上面的&#x2F;home&#x2F;a&#x2F;b就不行了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Route exact=&#123;true&#125;  path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;Route exact path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br></pre></td></tr></table></figure>

<p>​	</p>
<h2 id="初始化路由"><a href="#初始化路由" class="headerlink" title="初始化路由"></a>初始化路由</h2><p>在配置好路由，最开始打开页面的时候，应该是不会匹配到任意一个组件。这个时候页面就显得极其不合适，此时应该默认的匹配到一个组件。</p>
<p><img data-src="/images/react/RouterDef.gif" alt="空组件"></p>
<p>此时就需要使用Redirect进行默认匹配了。如下的代码就是默认匹配&#x2F;home路径所到的组件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Switch&gt;</span><br><span class="line">    &lt;Route path=&quot;/about&quot;component=&#123;About&#125;/&gt;</span><br><span class="line">    &#123;/* exact=&#123;true&#125;：开启严格匹配的模式，路径必须一致 */&#125;</span><br><span class="line">    &lt;Route   path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">    &#123;/* Redirect:如果上面的都没有匹配到，就匹配到这个路径下面 */&#125;</span><br><span class="line">    &lt;Redirect  to = &quot;/home&quot;/&gt;</span><br><span class="line">&lt;/Switch&gt;</span><br></pre></td></tr></table></figure>

<p>就可以做到如下的效果：</p>
<h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a><img data-src="/images/react/RouterSetDef.gif" alt="设置默认值">嵌套路由</h2><p>简单来说就是在一个路由组件中又使用了一个路由，就形成了嵌套路由。</p>
<p>举个例子来说：</p>
<p>我们在home这个路由组件中又添加两个组件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">APP.jsx:</span><br><span class="line">&lt;Route   path=&quot;/home&quot; component=&#123;Home&#125;/&gt;</span><br><span class="line">Home.jsx:</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;ul className=&quot;nav nav-tabs&quot;&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    	&lt;MyNavLink to = &quot;/home/news&quot;&gt;News&lt;/MyNavLink&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;li&gt;</span><br><span class="line">    	&lt;MyNavLink  to = &quot;/home/message&quot;&gt;Message&lt;/MyNavLink&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">        &lt;Route path = &quot;/home/news&quot; component=&#123;News&#125; /&gt;</span><br><span class="line">        &lt;Route path = &quot;/home/message&quot; component=&#123;Message&#125; /&gt;</span><br><span class="line">        &lt;Redirect to=&quot;/home/message&quot;/&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p> react中路由的注册是有顺序的，因此在匹配的时候也是按照这个顺序进行的，因此会先匹配父组件中的路由 </p>
<p>比如上面的 &#x2F;home&#x2F;news的路由处理过程：</p>
<p>1.因为父组件home的路由是先注册的，因此在匹配的时候先去找home的路由，也就是根据&#x2F;home&#x2F;news先模糊匹配到&#x2F;home</p>
<p>2.在去Home组件里面去匹配相应的路由，从而找到了&#x2F;home&#x2F;news进行匹配，因此找到了News组件。</p>
<p>但是如果开启精确匹配，就会在第一步的时候卡住，这个时候就走不下去了。<strong>因此不要轻易的使用精确匹配</strong></p>
]]></content>
      <categories>
        <category>Study</category>
        <category>React</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>react</tag>
        <tag>frontend</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/07/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/07/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<h1 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h1><h3 id="HTTP-的基本概念"><a href="#HTTP-的基本概念" class="headerlink" title="HTTP 的基本概念"></a>HTTP 的基本概念</h3><p>http: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端<code>请求和应答的标准（TCP）</code>，用于从 WWW 服务器传输超文本到本地浏览器的<code>超文本传输协议</code>。</p>
<h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。客户端向服务器发送一个请求报文，服务器以一个状态行作为响应。</p>
<h3 id="HTTP请求-x2F-响应的步骤"><a href="#HTTP请求-x2F-响应的步骤" class="headerlink" title="HTTP请求&#x2F;响应的步骤"></a>HTTP请求&#x2F;响应的步骤</h3><ul>
<li>1.客户端连接到Web服务器</li>
<li>2.发送HTTP请求</li>
<li>3.服务器接受请求并返回HTTP响应</li>
<li>4.释放TCP连接</li>
<li>5.客户端（浏览器）解析HTML内容</li>
</ul>
<blockquote>
<p>记忆口诀：连接发送加响应，释放解析整过程。</p>
</blockquote>
<span id="more"></span>

<h3 id="HTTP-的-5-种方法"><a href="#HTTP-的-5-种方法" class="headerlink" title="HTTP 的 5 种方法"></a>HTTP 的 5 种方法</h3><ul>
<li>GET—获取资源</li>
<li>POST—传输资源</li>
<li>PUT—更新资源</li>
<li>DELETE—删除资源</li>
<li>HEAD—获取报文首部</li>
</ul>
<h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><p><strong>1.浏览器回退表现不同</strong> GET在浏览器回退时是无害的，而POST会再次提交请求<br><strong>2.浏览器对请求地址的处理不同</strong> GET请求地址会被浏览器主动缓存，而POST不会，除非手动设置<br><strong>3.浏览器对响应的处理不同</strong>GET请求参数会被完整的保留在浏览器历史记录里，而POST中的参数不会被保留<br><strong>4.参数大小不同.</strong> GET请求在URL中传送的参数是有长度的限制，而POST没有限制<br><strong>5.安全性不同.</strong> GET参数通过URL传递，会暴露，不安全；POST放在Request Body中，相对更安全<br><strong>6.针对数据操作的类型不同</strong>.GET对数据进行查询，POST主要对数据进行增删改！简单说，GET是只读，POST是写。</p>
<h3 id="HTTP报文的组成成分"><a href="#HTTP报文的组成成分" class="headerlink" title="HTTP报文的组成成分"></a>HTTP报文的组成成分</h3><p>请求报文{ 请求行、请求头、空行、请求体 } 请求行：{http方法、页面地址、http协议、http版本} 响应报文{ 状态行、响应头、空行、响应体 }</p>
<p><strong>Request Header:</strong></p>
<ol>
<li><strong>GET &#x2F;sample.Jsp HTTP&#x2F;1.1</strong>  &#x2F;&#x2F;请求行</li>
<li><strong>Host:</strong>  <a href="http://www.uuid.online/">www.uuid.online/</a> &#x2F;&#x2F;请求的目标域名和端口号</li>
<li><strong>Origin:</strong> <a href="http://localhost:8081/">http://localhost:8081/</a>  &#x2F;&#x2F;请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</li>
<li><strong>Referer:</strong> <a href="https://localhost:8081/link?query=xxxxx">https://localhost:8081/link?query=xxxxx</a> &#x2F;&#x2F;请求资源的完整URI</li>
<li><strong>User-Agent:</strong> Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;67.0.3396.99 Safari&#x2F;537.36 &#x2F;&#x2F;浏览器信息</li>
<li><strong>Cookie:</strong>  BAIDUID&#x3D;FA89F036:FG&#x3D;1; BD_HOME&#x3D;1; sugstore&#x3D;0  &#x2F;&#x2F;当前域名下的Cookie</li>
<li><strong>Accept:</strong> text&#x2F;html,image&#x2F;apng  &#x2F;&#x2F;代表客户端希望接受的数据类型是html或者是png图片类型 </li>
<li><strong>Accept-Encoding:</strong> gzip, deflate  &#x2F;&#x2F;代表客户端能支持gzip和deflate格式的压缩</li>
<li><strong>Accept-Language:</strong> zh-CN,zh;q&#x3D;0.9  &#x2F;&#x2F;代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)</li>
<li><strong>Connection:</strong> keep-alive  &#x2F;&#x2F;告诉服务器，客户端需要的tcp连接是一个长连接</li>
</ol>
<p><strong>Response Header:</strong></p>
<ol>
<li><strong>HTTP&#x2F;1.1 200 OK</strong>  &#x2F;&#x2F; 响应状态行</li>
<li><strong>Date:</strong>  Mon, 30 Jul 2018 02:50:55 GMT  &#x2F;&#x2F;服务端发送资源时的服务器时间</li>
<li><strong>Expires:</strong>  Wed, 31 Dec 1969 23:59:59 GMT &#x2F;&#x2F;比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页</li>
<li><strong>Cache-Control:</strong>  no-cache  &#x2F;&#x2F; 现在最多使用的控制缓存的方式，会和服务器进行缓存验证，具体见<a href="https://www.cnblogs.com/amiezhang/p/9389537.html">博文”Cache-Control“</a></li>
<li><strong>etag:</strong>  “fb8ba2f80b1d324bb997cbe188f28187-ssl-df”  &#x2F;&#x2F; 一般是<a href="http://www.t086.com/article/5207">Nginx静态服务器</a>发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match”</li>
<li><strong>Last-Modified:</strong>  Fri, 27 Jul 2018 11:04:55 GMT &#x2F;&#x2F;是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容</li>
<li><strong>Content-Type:</strong>  text&#x2F;html; charset&#x3D;utf-8  &#x2F;&#x2F;如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码</li>
<li><strong>Content-Encoding:</strong>  gzip  &#x2F;&#x2F;告诉客户端，应该采用gzip对资源进行解码</li>
<li><strong>Connection:</strong>  keep-alive  &#x2F;&#x2F;告诉客户端服务器的tcp连接也是一个长连接</li>
</ol>
<h3 id="https-的基本概念"><a href="#https-的基本概念" class="headerlink" title="https 的基本概念"></a>https 的基本概念</h3><p>https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。 </p>
<p>https 协议的作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p>
<h3 id="http-和-https-的区别？"><a href="#http-和-https-的区别？" class="headerlink" title="http 和 https 的区别？"></a>http 和 https 的区别？</h3><ul>
<li>http 是超文本传输协议，信息是明文传输，https 则是具有安全性的 ssl 加密传输协议。</li>
<li>Https 协议需要 ca 证书，费用较高。 </li>
<li>使用不同的链接方式，端口也不同，一般，http 协议的端口为 80，https 的端口为 443。</li>
<li>http 的连接很简单，是无状态的。</li>
</ul>
<blockquote>
<p>记忆口诀：明文传输超文本，安全等级各不同。CA证书费用高，无状连接端难同。</p>
</blockquote>
<h4 id="https-协议的工作原理"><a href="#https-协议的工作原理" class="headerlink" title="https 协议的工作原理"></a>https 协议的工作原理</h4><p><img data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c42bc6f45451457fa6d614fb27534516~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<ol>
<li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li>
<li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li>
<li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li>
<li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li>
</ol>
<blockquote>
<p>记忆口诀：一连二传三协商，四建五得六使用。</p>
</blockquote>
<h4 id="https-协议的优缺点"><a href="#https-协议的优缺点" class="headerlink" title="https 协议的优缺点"></a>https 协议的优缺点</h4><ul>
<li>HTTPS 协议要比 http 协议<code>安全</code>，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li>
<li>https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。 </li>
<li>https <code>缓存</code>不如 http 高效，会增加数据开销。 </li>
<li>SSL 证书也需要钱，功能越强大的<code>证书费</code>用越高。 </li>
<li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li>
</ul>
<h3 id="TCP-x2F-IP网络模型"><a href="#TCP-x2F-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h3><p>TCP&#x2F;IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p>
<ul>
<li>链路层：负责封装和解封装IP报文，发送和接受ARP&#x2F;RARP报文等。</li>
<li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li>
<li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li>
<li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li>
</ul>
<p><img data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2fa80b3b48a84bd18d8e708c56a1dc22~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/baf3d5df95a74f47a1d779ee50c3411f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<ol>
<li>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li>
<li>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack&#x3D;j+1），<code>同时也发送一个自己的SYN包</code>（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</span><br></pre></td></tr></table></figure>


<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol>
<li><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN&#x3D;1，其序列号为seq&#x3D;u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
</ol>
<p>2）<code>服务器收到连接释放报文，发出确认报文</code>，ACK&#x3D;1，ack&#x3D;u+1，并且带上自己的序列号seq&#x3D;v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</p>
<p>3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</p>
<p>4）<code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN&#x3D;1，ack&#x3D;u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq&#x3D;w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p>
<p>5）<code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK&#x3D;1，ack&#x3D;w+1，而自己的序列号是seq&#x3D;u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</p>
<p>6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><ol>
<li><p>TCP是面向<code>连接</code>的，而UDP是面向无连接的。</p>
</li>
<li><p>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</p>
</li>
<li><p>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</p>
</li>
<li><p>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</p>
</li>
</ol>
<h3 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><ol>
<li><p>跨域的原理</p>
<p> <strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。<br> <strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br> <strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p>
</li>
<li><p>解决方案</p>
<p> 最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p>
<ul>
<li><p><strong>JSONP</strong>：<br>  ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>
<p>  步骤：</p>
<ol>
<li>去创建一个script标签</li>
<li>script的src属性设置接口地址</li>
<li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li>
<li>通过定义函数名去接受返回的数据</li>
</ol>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态创建 script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 script 的 src 属性，并设置请求地址</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3000/?callback=getData&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 script 生效</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>

<p>  <strong>JSONP 的缺点</strong>:<br>  JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p>
</li>
<li><p><strong>document.domain</strong>  基础域名相同 子域名不同</p>
</li>
<li><p><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</p>
</li>
<li><p><strong>CORS</strong> CORS(Cross-origin resource sharing)跨域资源共享 服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p>
</li>
<li><p><strong>proxy代理</strong> 目前常用方式</p>
</li>
<li><p><strong>window.postMessage()</strong>  利用h5新特性 window.postMessage()</p>
</li>
<li><p><strong>Websocket</strong></p>
</li>
</ul>
</li>
</ol>
<h3 id="Cookie、sessionStorage、localStorage-的区别"><a href="#Cookie、sessionStorage、localStorage-的区别" class="headerlink" title="Cookie、sessionStorage、localStorage 的区别"></a>Cookie、sessionStorage、localStorage 的区别</h3><p><strong>相同点</strong>：</p>
<ul>
<li>存储在客户端</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li>
<li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li>
<li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li>
</ul>
<h3 id="HTTP状态码及常见状态码"><a href="#HTTP状态码及常见状态码" class="headerlink" title="HTTP状态码及常见状态码"></a>HTTP状态码及常见状态码</h3><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><ul>
<li>1xx：指示信息类，表示请求已接受，继续处理</li>
<li>2xx：指示成功类，表示请求已成功接受</li>
<li>3xx：指示重定向，表示要完成请求必须进行更近一步的操作</li>
<li>4xx：指示客户端错误，请求有语法错误或请求无法实现</li>
<li>5xx：指示服务器错误，服务器未能实现合法的请求</li>
</ul>
<h4 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h4><ul>
<li><p>200 OK：客户端请求成功</p>
</li>
<li><p>301 Moved Permanently：所请求的页面已经永久重定向至新的URL</p>
</li>
<li><p>302 Found：所请求的页面已经临时重定向至新的URL</p>
</li>
<li><p>304 Not Modified 未修改。</p>
</li>
<li><p>403 Forbidden：对请求页面的访问被禁止</p>
</li>
<li><p>404 Not Found：请求资源不存在</p>
</li>
<li><p>500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</p>
</li>
<li><p>503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常</p>
</li>
<li><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码</p>
<ul>
<li>100 - 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分</li>
<li>101 - 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换</li>
</ul>
</li>
<li><p>2xx（成功）表示成功处理了请求的状态码</p>
<ul>
<li><code>200</code> - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页</li>
<li>201 - 已创建 请求成功并且服务器创建了新的资源</li>
<li>202 - 已接受 服务器已接受请求，但尚未处理</li>
<li>203 - 非授权信息 服务器已经成功处理了请求，但返回的信息可能来自另一来源</li>
<li>204 - 无内容 服务器成功处理了请求，但没有返回任何内容</li>
<li>205 - 重置内容 服务器成功处理了请求，但没有返回任何内容</li>
</ul>
</li>
<li><p>3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向</p>
<ul>
<li>300 - 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择</li>
<li><code>301</code> - 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置</li>
<li><code>302</code> - 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li>
<li>303 - 查看其它位置 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码</li>
<li><code>304</code> - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容</li>
<li>305 - 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</li>
<li><code>307</code> - 临时性重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求</li>
</ul>
</li>
<li><p>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</p>
<ul>
<li><code>400</code> - 错误请求 服务器不理解请求的语法</li>
<li><code>401</code> - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li>
<li><code>403</code> - 禁止 服务器拒绝请求</li>
<li><code>404</code> - 未找到 服务器找不到请求的网页</li>
<li>405 - 方法禁用 禁用请求中指定的方法</li>
<li>406 - 不接受 无法使用请求的内容特性响应请求的网页</li>
<li><code>407</code> - 需要代理授权 此状态码与401（未授权）类似，但指定请求者应当授权使用代理</li>
<li><code>408</code> - 请求超时 服务器等候请求时发生超时</li>
<li>410 - 已删除 如果请求的资源已永久删除，服务器就会返回此响应</li>
<li><code>413</code> - 请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力</li>
<li><code>414</code> - 请求的URI过长 请求的URI（通常为网址）过长，服务器无法处理</li>
</ul>
</li>
<li><p>5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</p>
<ul>
<li><code>500</code> - 服务器内部错误 服务器遇到错误，无法完成请求</li>
<li>501 - 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li>
<li><code>502</code> - 错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应</li>
<li><code>503</code> - 服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态</li>
<li><code>504</code> - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求</li>
<li>505 - HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本</li>
</ul>
</li>
</ul>
<h3 id="介绍下304过程"><a href="#介绍下304过程" class="headerlink" title="介绍下304过程"></a>介绍下304过程</h3><ul>
<li><p>a. 浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。</p>
</li>
<li><p>b. 强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。</p>
</li>
<li><p>c. 协商缓存Last-Modify&#x2F;If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p>
</li>
</ul>
<h3 id="浏览器的缓存机制-强制缓存-amp-amp-协商缓存"><a href="#浏览器的缓存机制-强制缓存-amp-amp-协商缓存" class="headerlink" title="浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存"></a>浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 – 服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中HTTP头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05b3fe9c411f4881a8b22fe37eae170b~tplv-k3u1fbpfcp-zoom-1.image" alt="图片"></p>
<p>由上图我们可以知道：</p>
<ul>
<li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li>
<li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li>
</ul>
<p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p>
<ul>
<li><p><strong>强制缓存</strong></p>
<p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。</p>
<p>强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：</p>
<ol>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li>
<li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li>
<li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li>
</ol>
</li>
<li><p><strong>协商缓存</strong></p>
<p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中Etag &#x2F; If-None-Match的优先级比Last-Modified &#x2F; If-Modified-Since高。协商缓存主要有以下两种情况：</p>
<ol>
<li>协商缓存生效，返回304</li>
<li>协商缓存失效，返回200和请求结果结果</li>
</ol>
</li>
</ul>
<p><img data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0ce991db4847b98d9f049f9ffa5c93~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>传送门 ☞ <a href="https://juejin.cn/post/6992843117963509791" title="https://juejin.cn/post/6992843117963509791"># 彻底理解浏览器的缓存机制</a></p>
<h3 id="HTTP-请求跨域问题-1"><a href="#HTTP-请求跨域问题-1" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><ol>
<li><p>跨域的原理</p>
<p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。跨域访问是被各大浏览器所默认禁止的。<br><strong>同源策略</strong>,是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。<br><strong>跨域原理</strong>，即是通过各种方式，<code>避开浏览器的安全限制</code>。</p>
</li>
<li><p>解决方案</p>
<p>最初做项目的时候，使用的是jsonp，但存在一些问题，使用get请求不安全，携带数据较小，后来也用过iframe，但只有主域相同才行，也是存在些问题，后来通过了解和学习发现使用代理和proxy代理配合起来使用比较方便，就引导后台按这种方式做下服务器配置，在开发中使用proxy，在服务器上使用nginx代理，这样开发过程中彼此都方便，效率也高；现在h5新特性还有 windows.postMessage()</p>
<ul>
<li><p><strong>JSONP</strong>：<br>ajax 请求受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链 接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是 返回一段调用某个函数的 js 代码，在 src 中进行了调用，这样实现了跨域。</p>
<p>步骤：</p>
<ol>
<li>去创建一个script标签</li>
<li>script的src属性设置接口地址</li>
<li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据</li>
<li>通过定义函数名去接受返回的数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态创建 script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getData</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 script 的 src 属性，并设置请求地址</span></span><br><span class="line">script.<span class="property">src</span> = <span class="string">&#x27;http://localhost:3000/?callback=getData&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 script 生效</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script);</span><br></pre></td></tr></table></figure>

<p><strong>JSONP 的缺点</strong>:<br>JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p>
</li>
<li><p><strong>document.domain</strong> 基础域名相同 子域名不同</p>
</li>
<li><p><strong>window.name</strong> 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p>
</li>
<li><p><strong>CORS</strong><br>CORS(Cross-origin resource sharing)跨域资源共享 是一种机制，是目前主流的跨域解决方案，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p>
<p>1.浏览器端会自动向请求头添加origin字段，表明当前请求来源。<br>2.服务器设置Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers等 HTTP响应头字段之后，浏览器将会允许跨域请求。</p>
<p><strong>预检</strong></p>
<p>但是还有复杂一点的请求，我们需要先发OPTIONS请求，a.com想请求b.com它需要发一个自定义的Headers：X-ABC和content-type，这个时候就不是简单请求了， a.com要给b.com 发一个options请求，它其实在问b.com我用post行不行，还想在Headers中带X-ABC和content-type；并不是所有的headers都发这个OPTIONS请求，因为X-ABC是自定义的，所以需要发；b.com看到OPTIONS请求，先不会返回数据，先检查自己的策略，看看能不能支持这次请求，如果支持就返回200。</p>
<p>OPTIONS请求返回以下报文</p>
<p>HTTP&#x2F;2.0 20 OK<br>Access-Control-Allow-Origin:<a href="https://a.com/">https://a.com</a><br>Access-Control-Allow-Methods:POST,GET,OPTIONS<br>Access-Control-Allow-Headers:X-ABC,Content-Type<br>Access-Control-Max-Age:86400 &#x2F;&#x2F; 告诉浏览器这个策略生效时间为一个小时，在一个小时之内发送类似的请求，不用在问服务端了，相当于缓存了<br>浏览器收到了OPTIONS的返回，会在发一次，这一次才是真正的请求数据，这次headers会带上X-ABC、contentType。</p>
<p>整体的过程cors将请求分为2种，简单请求和复杂请求，需不需要发送OPTIONS浏览器说的算，浏览器判断是简单请求还是复杂请求，cors是非常广泛的跨域手段 这里的缺点是OPTIONS请求也是一次请求，消耗带宽，真正的请求也会延迟。</p>
</li>
<li><p>最方便的跨域方案 <strong>proxy代理+ Nginx</strong><br>  nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</p>
<p>  跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制。</p>
<p>  反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收 internet 上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给 internet 上请求链接的客户端。现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</p>
</li>
<li><p><strong>window.postMessage()</strong> 利用h5新特性window.postMessage()</p>
</li>
</ul>
</li>
</ol>
<p>跨域传送门 ☞ <a href="https://juejin.cn/post/7003232769182547998"># 跨域，不可不知的基础概念</a></p>
<h3 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h3><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<p><strong>粘包出现原因</strong></p>
<p>简单得说，在流传输中出现，UDP不会出现粘包，因为它有<strong>消息边界</strong></p>
<p>粘包情况有两种，一种是<code>粘在一起的包都是完整的数据包</code>，另一种情况是<code>粘在一起的包有不完整的包</code>。</p>
<p>为了<strong>避免粘包</strong>现象，可采取以下几种措施：</p>
<p>（1）对于发送方引起的粘包现象，用户可通过编程设置来避免，<code>TCP提供了强制数据立即传送的操作指令push</code>，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；</p>
<p>（2）对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、<code>提高接收进程优先级等措施</code>，使其及时接收数据，从而尽量避免出现粘包现象；</p>
<p>（3）由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<code>分包多发</code>。</p>
<p>以上提到的三种措施，都有其不足之处。</p>
<p>（1）第一种编程设置方法虽然可以避免发送方引起的粘包，但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</p>
<p>（2）第二种方法只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</p>
<p>（3）第三种方法虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</p>
<blockquote>
<p>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。实验证明这种方法是高效可行的。</p>
</blockquote>
<h3 id="客户端与服务端长连接的几种方式"><a href="#客户端与服务端长连接的几种方式" class="headerlink" title="客户端与服务端长连接的几种方式"></a>客户端与服务端长连接的几种方式</h3><ol>
<li><p><strong>ajax 轮询</strong><br> <strong>实现原理</strong>：ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。</p>
<p> <strong>优点</strong>：可实现基础（指间隔时间较短）的数据更新。</p>
<p> <strong>缺点</strong>：这种方法也只是尽量的模拟即时传输，但并非真正意义上的即时通讯，很有可能出现客户端请求时，服务端数据并未更新。或者服务端数据已更新，但客户端未发起请求。导致多次请求资源浪费，效率低下。【<code>数据更新不及时，效率低下</code>】</p>
</li>
<li><p><strong>long poll 长轮询</strong></p>
<p> <strong>实现原理</strong>：<br> long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0 中客户端可以设置请求头 Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在 HTTP1.1 中默认使用了 Connection:keep-alive 长连接。</p>
<p> <strong>优点</strong>：减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。</p>
<p> <strong>缺点</strong>：无法处理高并发，当客户端请求量大，请求频繁时对服务器的处理能力要求较高。服务器一直保持连接会消耗资源，需要同时维护多个线程，服务器所能承载的 TCP 连接数是有上限的，这种轮询很容易把连接数顶满。每次通讯都需要客户端发起，服务端不能主动推送。【<code>无法处理高并发，消耗服务器资源严重，服务端不能主动推送</code>】</p>
</li>
<li><p><strong>iframe 长连接</strong></p>
<p> <strong>实现原理：</strong><br> 在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。</p>
<p> <strong>优点</strong>：消息及时传输。</p>
<p> <strong>缺点</strong>：<code>消耗服务器资源</code>。</p>
</li>
<li><p><strong>WebSocket</strong></p>
<p> <strong>实现原理</strong>：<br> Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。</p>
<p> Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。</p>
<p> Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。</p>
<p> <strong>优点</strong>：<br> 双向通信。客户端和服务端双方都可以主动发起通讯。<br> 没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。<br> 数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。<br> 传输效率高。因为只需要一次连接，所以数据传输效率高。</p>
<p> <strong>缺点</strong>：<br> 长连接需要后端处理业务的代码更稳定，推送消息相对复杂；<br> 长连接受网络限制比较大，需要处理好重连。<br> 兼容性，WebSocket 只支持 IE10 及其以上版本。<br> 服务器长期维护长连接需要一定的成本，各个浏览器支持程度不一；<br> 成熟的 HTTP 生态下有大量的组件可以复用，WebSocket 则没有，遇到异常问题难以快速定位快速解决。【需要后端代码稳定，受网络限制大，兼容性差，维护成本高，生态圈小】</p>
</li>
</ol>
<h3 id="利用Socket建立网络连接的步骤"><a href="#利用Socket建立网络连接的步骤" class="headerlink" title="利用Socket建立网络连接的步骤"></a>利用Socket建立网络连接的步骤</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket ，另一个运行于服务器端，称为ServerSocket 。</p>
<p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p>
<p>　　1、服务器监听：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</p>
<p>　　2、客户端请求：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。</p>
<p>　　为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</p>
<p>　　3、连接确认：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。</p>
<p>而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</p>
<h3 id="非对称加密RSA"><a href="#非对称加密RSA" class="headerlink" title="非对称加密RSA"></a>非对称加密RSA</h3><p>简介： </p>
<ol>
<li>对称加密算法又称现代加密算法。 </li>
<li>非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。 </li>
<li>非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey) </li>
<li>公开密钥和私有密钥是一对</li>
</ol>
<p>如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。 <br>如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。</p>
<p>特点： <br>算法强度复杂，安全性依赖于算法与密钥。 <br>加密解密速度慢。</p>
<p>与对称加密算法的对比： <br>对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。 <br>非对称加密有两种密钥，其中一个是公开的。</p>
<p>RSA应用场景： <br>由于RSA算法的加密解密速度要比对称算法速度慢很多，在实际应用中，通常采取 <br>数据本身的加密和解密使用对称加密算法(AES)。 用RSA算法加密并传输对称算法所需的密钥。</p>
<h3 id="HTTP1、HTTP2、HTTP3"><a href="#HTTP1、HTTP2、HTTP3" class="headerlink" title="HTTP1、HTTP2、HTTP3"></a>HTTP1、HTTP2、HTTP3</h3><p>HTTP&#x2F;2 相比于 HTTP&#x2F;1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，虽如此但HTTP&#x2F;2并非完美的，HTTP&#x2F;3 就是为了解决 HTTP&#x2F;2 所存在的一些问题而被推出来的。</p>
<h3 id="HTTP1-1-的缺陷"><a href="#HTTP1-1-的缺陷" class="headerlink" title="HTTP1.1 的缺陷"></a><strong>HTTP1.1 的缺陷</strong></h3><ol>
<li><p>高延迟 — 队头阻塞(Head-Of-Line Blocking)</p>
<p><code>队头阻塞</code>是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p>
<p>针对队头阻塞的解决办法:</p>
<ul>
<li><code>将同一页面的资源分散到不同域名下，提升连接上限</code>。 </li>
<li><code>合并小文件减少资源数</code>，使用精灵图。</li>
<li><code>内联(Inlining)资源</code>是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。</li>
<li><code>减少请求数量</code>，合并文件。</li>
</ul>
</li>
<li><p>无状态特性 — 阻碍交互</p>
<p><code>无状态是指协议对于连接状态没有记忆能力</code>。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。</p>
<p><code>Header里携带的内容过大，在一定程度上增加了传输的成本</code>。且请求响应报文里有大量字段值都是重复的。</p>
</li>
<li><p>明文传输 — 不安全性</p>
<p>HTTP&#x2F;1.1在传输数据时，所有<code>传输的内容都是明文</code>，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。</p>
</li>
<li><p>不支持服务端推送</p>
</li>
</ol>
<blockquote>
<p>记忆口诀：队头阻塞高延迟，无状态阻交互，明文传输不安全，服务推送不支持。</p>
</blockquote>
<p><strong>HTTP 1.1 排队问题</strong></p>
<p>HTTP 1.1多个文件共用一个TCP，这样可以减少tcp握手，这样3个文件就不用握手9次了，不过这样请求文件需要排队，请求和返回都需要排队， 如果第一个文件响应慢，会阻塞后面的文件，这样就产生了对头的等待问题。</p>
<p>有的网站可能会有很多文件，浏览器处于对机器性能的考虑，它不可能让你无限制的发请求建连接，因为建立连接需要占用资源，浏览器不想把用户的网络资源都占用了，所以浏览器最多会建立6个tcp连接；如果有上百个文件可能都需要排队，http2.0正在解决这个问题。</p>
<p><img data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ecdc60670194df7957ee59e1f56701f~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h3 id="SPDY-协议与-HTTP-x2F-2-简介"><a href="#SPDY-协议与-HTTP-x2F-2-简介" class="headerlink" title="SPDY 协议与 HTTP&#x2F;2 简介"></a>SPDY 协议与 HTTP&#x2F;2 简介</h3><h4 id="1、HTTP-x2F-2-简介"><a href="#1、HTTP-x2F-2-简介" class="headerlink" title="1、HTTP&#x2F;2 简介"></a>1、HTTP&#x2F;2 简介</h4><p>HTTP&#x2F;2是现行HTTP协议（HTTP&#x2F;1.x）的替代，但它不是重写。<strong>HTTP&#x2F;2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）</strong> 。</p>
<h4 id="2、HTTP-x2F-2-新特性"><a href="#2、HTTP-x2F-2-新特性" class="headerlink" title="2、HTTP&#x2F;2 新特性"></a>2、HTTP&#x2F;2 新特性</h4><h4 id="1、二进制传输"><a href="#1、二进制传输" class="headerlink" title="1、二进制传输"></a>1、二进制传输</h4><p><code>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩</code>。我们先来介绍二进制传输,HTTP&#x2F;2 采用二进制格式传输数据，而非HTTP&#x2F;1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。<code>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</code>。</p>
<h4 id="2、Header-压缩"><a href="#2、Header-压缩" class="headerlink" title="2、Header 压缩"></a>2、Header 压缩</h4><p>HTTP&#x2F;2并没有使用传统的压缩算法，而是开发了专门的”HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>
<h4 id="3、多路复用"><a href="#3、多路复用" class="headerlink" title="3、多路复用"></a>3、多路复用</h4><p>在 HTTP&#x2F;2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输。</p>
<p><img data-src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f756ad3403bc4fe18e970c56677c796e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<h4 id="4、Server-Push"><a href="#4、Server-Push" class="headerlink" title="4、Server Push"></a>4、Server Push</h4><p>HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。减少等待的延迟，这被称为”<code>服务器推送</code>“（ Server Push，也叫 Cache push）</p>
<h4 id="5、提高安全性"><a href="#5、提高安全性" class="headerlink" title="5、提高安全性"></a>5、提高安全性</h4><p>出于兼容的考虑，HTTP&#x2F;2延续了HTTP&#x2F;1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。</p>
<p>但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP&#x2F;2，<strong>所以“事实上”的HTTP&#x2F;2是加密的</strong>。也就是说，互联网上通常所能见到的HTTP&#x2F;2都是使用”https”协议名，跑在TLS上面。HTTP&#x2F;2协议定义了两个字符串标识符：“h2”表示加密的HTTP&#x2F;2，“h2c”表示明文的HTTP&#x2F;2。</p>
<h4 id="6、防止对头阻塞"><a href="#6、防止对头阻塞" class="headerlink" title="6、防止对头阻塞"></a>6、防止对头阻塞</h4><p>http1.1如果第一个文件阻塞，第二个文件也就阻塞了。</p>
<p><img data-src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b67bd1f793a3425d9e8a415cae9b7863~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>http2.0的解决，把3个请求打包成一个小块发送过去，即使第一个阻塞了，后面2个也可以回来；相当于3个文件同时请求，就看谁先回来谁后回来，阻塞的可能就后回来，对带宽的利用是最高的；但没有解决TCP的对头阻塞，如果TCP发过去的一个分包发丢了，他会重新发一次；http2.0的解决了大文件的阻塞。</p>
<p><img data-src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77d8ae8e0de44f3aa693f0626a346d4c~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p>
<p>一个分包请求3个文件，即使第一个阻塞了，第二个也能返回</p>
<h3 id="HTTP-x2F-2-的缺点"><a href="#HTTP-x2F-2-的缺点" class="headerlink" title="HTTP&#x2F;2 的缺点"></a>HTTP&#x2F;2 的缺点</h3><p>虽然 HTTP&#x2F;2 解决了很多之前旧版本的问题，但它还是存在一个巨大的问题，<strong>主要是底层支撑的 TCP 协议造成的</strong>。HTTP&#x2F;2的缺点主要有以下几点：</p>
<ol>
<li>TCP 以及 TCP+TLS 建立连接时延时</li>
<li>TCP 的队头阻塞并没有彻底解决</li>
<li>多路复用导致服务器压力上升也容易 Timeout</li>
</ol>
<h3 id="HTTP-x2F-3-新特性"><a href="#HTTP-x2F-3-新特性" class="headerlink" title="HTTP&#x2F;3 新特性"></a>HTTP&#x2F;3 新特性</h3><h4 id="1、HTTP-x2F-3简介"><a href="#1、HTTP-x2F-3简介" class="headerlink" title="1、HTTP&#x2F;3简介"></a>1、HTTP&#x2F;3简介</h4><p>Google 在推SPDY的时候就搞了个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而“HTTP over QUIC”就是HTTP&#x2F;3，真正“完美”地解决了“队头阻塞”问题。</p>
<p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。</p>
<h4 id="2、QUIC新功能"><a href="#2、QUIC新功能" class="headerlink" title="2、QUIC新功能"></a>2、QUIC新功能</h4><p>QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP&#x2F;2的“流”和“多路复用”，单个“流”是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p>
<ul>
<li><p><strong>实现了类似TCP的流量控制、传输可靠性的功能</strong></p>
<p>  虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p>
</li>
<li><p><strong>实现了快速握手功能</strong></p>
<p>  由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong>。</p>
</li>
<li><p><strong>集成了TLS加密功能</strong></p>
</li>
<li><p><strong>多路复用，彻底解决TCP中队头阻塞的问题</strong></p>
<p>  和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。</p>
</li>
<li><p><strong>连接迁移</strong></p>
<p>  TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>HTTP&#x2F;1.1有两个主要的缺点：安全不足和性能不高。</li>
<li>HTTP&#x2F;2完全兼容HTTP&#x2F;1，是“更安全的HTTP、更快的HTTPS”，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li>
<li>QUIC 基于 UDP 实现，是 HTTP&#x2F;3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</li>
</ul>
<h3 id="理解xss，csrf，ddos攻击原理以及避免方式"><a href="#理解xss，csrf，ddos攻击原理以及避免方式" class="headerlink" title="理解xss，csrf，ddos攻击原理以及避免方式"></a>理解xss，csrf，ddos攻击原理以及避免方式</h3><p><code>XSS</code>(<code>Cross-Site Scripting</code>，<strong>跨站脚本攻击</strong>)是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 <code>cookie，session tokens</code>，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p>
<p><code>CSRF</code>（<code>Cross-site request forgery</code>）<strong>跨站请求伪造</strong>：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p>
<p><strong>XSS避免方式：</strong></p>
<ol>
<li><code>url</code>参数使用<code>encodeURIComponent</code>方法转义</li>
<li>尽量不是有<code>InnerHtml</code>插入<code>HTML</code>内容</li>
<li>使用特殊符号、标签转义符。</li>
</ol>
<p><code>CSRF</code>避免方式：</p>
<ol>
<li><p>添加验证码</p>
</li>
<li><p>使用token</p>
<ul>
<li>服务端给用户生成一个token，加密后传递给用户</li>
<li>用户在提交请求时，需要携带这个token</li>
<li>服务端验证token是否正确</li>
</ul>
</li>
</ol>
<p><code>DDoS</code>又叫分布式拒绝服务，全称 <code>Distributed Denial of Service</code>，其原理就是利用大量的请求造成资源过载，导致服务不可用。</p>
<p><strong><code>DDos</code>避免方式：</strong></p>
<ol>
<li>限制单IP请求频率。</li>
<li>防火墙等防护设置禁止<code>ICMP</code>包等</li>
<li>检查特权端口的开放</li>
</ol>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzkzNzI0MDMxNQ==&mid=2247487116&idx=1&sn=09187eeb7e45faa1bee86ff48ae14be1&source=41#wechat_redirect">360技术：嗨，送你一张Web性能优化地图</a></p>
]]></content>
      <categories>
        <category>Study</category>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>notes</tag>
        <tag>frontend</tag>
      </tags>
  </entry>
</search>
